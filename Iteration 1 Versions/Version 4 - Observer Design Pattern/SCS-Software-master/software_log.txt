commit 8906a2d242e58247e0aafc152a0130185276e7f1
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:56:28 2022 -0600

    final commit

diff --git a/bin/org/control/software/CheckoutController.class b/bin/org/control/software/CheckoutController.class
index 1e12c1e..02b751d 100644
Binary files a/bin/org/control/software/CheckoutController.class and b/bin/org/control/software/CheckoutController.class differ
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
index 0fb7d28..6e47265 100644
Binary files a/bin/org/control/software/CoinSlotControlObserver.class and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index e47bb14..6a4f82a 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index f450f37..23613d9 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/bin/org/control/software/ReceiptPrinterControlObserver.class b/bin/org/control/software/ReceiptPrinterControlObserver.class
index 467d82a..bfe7b3a 100644
Binary files a/bin/org/control/software/ReceiptPrinterControlObserver.class and b/bin/org/control/software/ReceiptPrinterControlObserver.class differ
diff --git a/src/org/control/software/CheckoutController.java b/src/org/control/software/CheckoutController.java
index 132b078..bb10a9a 100644
--- a/src/org/control/software/CheckoutController.java
+++ b/src/org/control/software/CheckoutController.java
@@ -7,12 +7,14 @@ public class CheckoutController {
 	BanknoteValidatorControlObserver banknoteValidator = new BanknoteValidatorControlObserver();
 	CoinValidatorControlObserver coinValidator = new CoinValidatorControlObserver();
 	ReceiptPrinterControlObserver receiptPrinter = new ReceiptPrinterControlObserver();
-	private SelfCheckoutStation checkoutStation;
+	public SelfCheckoutStation checkoutStation;
+	public boolean checkedOut;
 	
-	public void checkout() {
+	public boolean checkout() {
 		
 		int checkoutTotal = banknoteValidator.totalValue + coinValidator.totalValue;
 		checkoutStation.printer.print('C');
+		return checkedOut = true;
 		
 	}
 	
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
index 905e268..e9550c2 100644
--- a/src/org/control/software/CoinSlotControlObserver.java
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -1,7 +1,6 @@
 package org.control.software;
-import java.math.BigDecimal;
-import java.util.Currency;
 
+import java.math.BigDecimal;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index b4ce98c..627c5af 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -1,7 +1,6 @@
 package org.control.software;
-import java.math.BigDecimal;
-import java.util.Currency;
 
+import java.math.BigDecimal;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 97453e3..da4b819 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -6,7 +6,6 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 
 
diff --git a/src/org/control/software/ReceiptPrinterControlObserver.java b/src/org/control/software/ReceiptPrinterControlObserver.java
index 81d4121..d1b3db4 100644
--- a/src/org/control/software/ReceiptPrinterControlObserver.java
+++ b/src/org/control/software/ReceiptPrinterControlObserver.java
@@ -12,8 +12,8 @@ import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
 public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
 	
 	private SelfCheckoutStation checkoutStation;
-	boolean outOfPaper;
-	boolean outOfInk;
+	public boolean outOfPaper;
+	public boolean outOfInk;
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		

commit ff94fdd90129615daeda8aec2d5e77b9362e6fac
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:30:20 2022 -0600

    updated control

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index b78d5f4..21c0bbb 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index e9ef587..f450f37 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index f6ee08d..12fb2db 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -9,7 +9,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 
 public class ItemsCollection extends Item {
 	
-	double weightInGrams;
+	public double weightInGrams;
 	
 	Map<Barcode, Double> weightsMap = new HashMap<Barcode, Double>();
 
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	public ItemsCollection(Barcode barcode, Double weightInGrams) {
+	public ItemsCollection(Barcode barcode, Double weightInGrams) throws NullPointerException {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index af69e3d..97453e3 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -21,8 +21,8 @@ public class ProductsCollection {
 	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
 	Map<Barcode, ItemsCollection> itemsMap = new HashMap<Barcode, ItemsCollection>();
 	
-	Barcode milkBarcode;
-	Barcode riceBarcode;
+	public Barcode milkBarcode;
+	public Barcode riceBarcode;
 	
 	/**
 	 * Constructor that initializes products collection.

commit c3ad49836c159ab1919bc145239949ab21d255dc
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:05:22 2022 -0600

    changed visibility of itemscollection construct

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 4ae161b..b78d5f4 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 032a0de..f6ee08d 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
+	public ItemsCollection(Barcode barcode, Double weightInGrams) {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));

commit 11870bc6852c08457d597733017ba0568ffdfbad
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 21:59:36 2022 -0600

    receipt printer observer

diff --git a/bin/org/control/software/ReceiptPrinterControlObserver.class b/bin/org/control/software/ReceiptPrinterControlObserver.class
index 01fcbad..467d82a 100644
Binary files a/bin/org/control/software/ReceiptPrinterControlObserver.class and b/bin/org/control/software/ReceiptPrinterControlObserver.class differ
diff --git a/src/org/control/software/ReceiptPrinterControlObserver.java b/src/org/control/software/ReceiptPrinterControlObserver.java
index 2823e51..81d4121 100644
--- a/src/org/control/software/ReceiptPrinterControlObserver.java
+++ b/src/org/control/software/ReceiptPrinterControlObserver.java
@@ -12,6 +12,8 @@ import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
 public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
 	
 	private SelfCheckoutStation checkoutStation;
+	boolean outOfPaper;
+	boolean outOfInk;
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -32,7 +34,7 @@ public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
 	 *            The device from which the event emanated.
 	 */
 	public void outOfPaper(ReceiptPrinter printer) {
-		//checkoutStation.printer.
+		outOfPaper = true;
 	}
 
 	/**
@@ -42,8 +44,7 @@ public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
 	 *            The device from which the event emanated.
 	 */
 	public void outOfInk(ReceiptPrinter printer) {
-		
-		
+		outOfInk = true;
 	}
 
 	/**

commit 824e15952ff5ee3b15f0ade26f54926affbfb70f
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 21:58:25 2022 -0600

    initial code for CheckoutController

diff --git a/bin/org/control/software/CheckoutController.class b/bin/org/control/software/CheckoutController.class
new file mode 100644
index 0000000..1e12c1e
Binary files /dev/null and b/bin/org/control/software/CheckoutController.class differ
diff --git a/bin/org/control/software/ReceiptPrinterControlObserver.class b/bin/org/control/software/ReceiptPrinterControlObserver.class
new file mode 100644
index 0000000..01fcbad
Binary files /dev/null and b/bin/org/control/software/ReceiptPrinterControlObserver.class differ
diff --git a/src/org/control/software/CheckoutController.java b/src/org/control/software/CheckoutController.java
new file mode 100644
index 0000000..132b078
--- /dev/null
+++ b/src/org/control/software/CheckoutController.java
@@ -0,0 +1,20 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+
+public class CheckoutController {
+	
+	BanknoteValidatorControlObserver banknoteValidator = new BanknoteValidatorControlObserver();
+	CoinValidatorControlObserver coinValidator = new CoinValidatorControlObserver();
+	ReceiptPrinterControlObserver receiptPrinter = new ReceiptPrinterControlObserver();
+	private SelfCheckoutStation checkoutStation;
+	
+	public void checkout() {
+		
+		int checkoutTotal = banknoteValidator.totalValue + coinValidator.totalValue;
+		checkoutStation.printer.print('C');
+		
+	}
+	
+
+}
diff --git a/src/org/control/software/ReceiptPrinterControlObserver.java b/src/org/control/software/ReceiptPrinterControlObserver.java
new file mode 100644
index 0000000..2823e51
--- /dev/null
+++ b/src/org/control/software/ReceiptPrinterControlObserver.java
@@ -0,0 +1,69 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
+	
+	private SelfCheckoutStation checkoutStation;
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.printer.enable();
+		
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.printer.disable();
+		
+	}
+	
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void outOfPaper(ReceiptPrinter printer) {
+		//checkoutStation.printer.
+	}
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void outOfInk(ReceiptPrinter printer) {
+		
+		
+	}
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void paperAdded(ReceiptPrinter printer) {
+		checkoutStation.printer.addInk(checkoutStation.printer.MAXIMUM_PAPER);
+	}
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void inkAdded(ReceiptPrinter printer) {
+		checkoutStation.printer.addInk(checkoutStation.printer.MAXIMUM_INK);
+	}
+}
+

commit 725ee6da9207ba3fe34e822c2eed0d9526d38dc8
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 15:37:32 2022 -0600

    committt

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index 8753456..a3cdcfb 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
index ea69851..d5ef6d3 100644
Binary files a/bin/org/control/software/BanknoteValidatorControlObserver.class and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index d620814..e47bb14 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index f5c889b..af6886c 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -15,9 +15,9 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
 	
 	private SelfCheckoutStation checkoutStation;
-	int totalBanknotes;
-	int totalValue;
-	int noteValue;
+	public int totalBanknotes;
+	public int totalValue;
+	public int noteValue;
 	Currency cad = Currency.getInstance("CAD");
 	
 	
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index 876f77a..25082a2 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -14,9 +14,9 @@ import org.lsmr.selfcheckout.devices.DisabledException;
 public class BanknoteValidatorControlObserver implements BanknoteValidatorObserver{
 	
 	private SelfCheckoutStation checkoutStation;
-	int totalBanknotes;
-	int totalValue;
-	int noteValue;
+	public int totalBanknotes;
+	public int totalValue;
+	public int noteValue;
 	Currency cad = Currency.getInstance("CAD");
 	
 	/**
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index f6cf6e0..b4ce98c 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -15,8 +15,8 @@ import org.lsmr.selfcheckout.devices.DisabledException;
  */
 public class CoinValidatorControlObserver implements CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
-	int totalCoins;
-	int totalValue;
+	public int totalCoins;
+	public int totalValue;
 	BigDecimal coinValue;
 
 	/**

commit 71f9d9334286de833be0555a1cf4657cf95c449d
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 15:05:16 2022 -0600

    fixed add to value logic

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index acb2841..8753456 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
index be0a38c..ea69851 100644
Binary files a/bin/org/control/software/BanknoteValidatorControlObserver.class and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
index bfd2dc5..ba40087 100644
Binary files a/bin/org/control/software/CoinTrayControlObserver.class and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 430a55f..d620814 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index 140b239..f5c889b 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -89,7 +89,9 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
 	 *            The device on which the event occurred.
 	 */
 	public void banknoteRemoved(BanknoteSlot slot){
+		
 		slot.removeDanglingBanknote();
+		totalValue -= noteValue;
 		totalBanknotes--;
 		
 	}
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index 00890f3..876f77a 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -60,11 +60,11 @@ public class BanknoteValidatorControlObserver implements BanknoteValidatorObserv
 		try {
 			validator.accept(banknote);
 			isValid = true;
+			totalBanknotes++;
+			totalValue += value;
 		} catch (DisabledException e) {
 			e.printStackTrace();
 		}
-		totalBanknotes++;
-		totalValue += value;
 		
 	}
 	
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
index dce5107..b305b5e 100644
--- a/src/org/control/software/CoinTrayControlObserver.java
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -29,8 +29,6 @@ public class CoinTrayControlObserver implements CoinTrayObserver {
 	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.enable();
-		
-		
 	}
 
 	/**
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index 4de0cac..f6cf6e0 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -57,11 +57,11 @@ public class CoinValidatorControlObserver implements CoinValidatorObserver{
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
+			totalCoins++;
+			totalValue += coinValue.intValue();
 		} catch (DisabledException e) {
 			e.printStackTrace();
 		}
-		totalCoins++;
-		totalValue += coinValue.intValue();
 	}
 	
 	/**

commit 38bd3054f3096cd3badeb3852b438c8cda90d02e
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 14:25:09 2022 -0600

    fixed merge issue

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index 4a72ebd..acb2841 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index eaf2003..140b239 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -3,9 +3,7 @@ import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
 import java.util.Currency;
-
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.DisabledException;

commit 47dcc38de65488eb13117a5cc67b7718c14efa5e
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 14:13:34 2022 -0600

    rebased

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index 5ec20f1..4a72ebd 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteStorageUnitControlObserver.class b/bin/org/control/software/BanknoteStorageUnitControlObserver.class
index e3b2324..d4fe9c2 100644
Binary files a/bin/org/control/software/BanknoteStorageUnitControlObserver.class and b/bin/org/control/software/BanknoteStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
index 6f886bc..be0a38c 100644
Binary files a/bin/org/control/software/BanknoteValidatorControlObserver.class and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
index 509831c..d4e6e2f 100644
Binary files a/bin/org/control/software/BarcodeScannerControlObserver.class and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 4d5cbfc..4ae161b 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 096d87c..e9ef587 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index f42b42f..eaf2003 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -11,7 +11,11 @@ import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 
-public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
+	
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
 	int totalValue;
@@ -19,6 +23,12 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 	Currency cad = Currency.getInstance("CAD");
 	
 	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteInput.enable();
@@ -26,6 +36,12 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 	
 	}
 
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteInput.disable();
@@ -33,6 +49,12 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 		
 	}
 	
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
 	public void banknoteInserted(BanknoteSlot slot){
 		
 		Banknote banknote = new Banknote(cad, noteValue);
@@ -44,6 +66,13 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 		
 	}
 	
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
 	public void banknoteEjected(BanknoteSlot slot){
 		
 		Banknote bankNote = new Banknote(cad, noteValue);
@@ -55,6 +84,12 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 		
 	}
 	
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
 	public void banknoteRemoved(BanknoteSlot slot){
 		slot.removeDanglingBanknote();
 		totalBanknotes--;
diff --git a/src/org/control/software/BanknoteStorageUnitControlObserver.java b/src/org/control/software/BanknoteStorageUnitControlObserver.java
index cabc319..a9ffc0e 100644
--- a/src/org/control/software/BanknoteStorageUnitControlObserver.java
+++ b/src/org/control/software/BanknoteStorageUnitControlObserver.java
@@ -3,7 +3,6 @@ package org.control.software;
 import java.util.Currency;
 
 import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
 import org.lsmr.selfcheckout.devices.DisabledException;
@@ -12,6 +11,9 @@ import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
 
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
 public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitObserver {
 
 	private SelfCheckoutStation checkoutStation;
@@ -19,29 +21,50 @@ public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitOb
 	int noteValue;
 	Currency cad = Currency.getInstance("CAD");
 	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteStorage.enable();
 	}
 
 	
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteStorage.disable();
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void banknotesFull(BanknoteStorageUnit unit) {
 		
 		if(unit.getBanknoteCount() > unit.getCapacity()) {
 			banknotesFull = true;
 		}
 		
-		
 	}
 
-	
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void banknoteAdded(BanknoteStorageUnit unit) {
 		
 		Banknote banknote = new Banknote(cad, noteValue);
@@ -53,7 +76,13 @@ public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitOb
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void banknotesLoaded(BanknoteStorageUnit unit) {
 		
 		Banknote banknote = new Banknote(cad, noteValue);
@@ -65,10 +94,15 @@ public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitOb
 		
 	}
 
-	
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void banknotesUnloaded(BanknoteStorageUnit unit) {
 		
-		Banknote banknote = new Banknote(cad, noteValue);
 		unit.unload();
 		
 	}
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index b0493fc..00890f3 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -8,25 +8,52 @@ import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
+/**
+ * Observes events emanating from a banknote validator.
+ */
 public class BanknoteValidatorControlObserver implements BanknoteValidatorObserver{
+	
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
 	int totalValue;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
 	
-	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteValidator.enable();
 	
 	}
 
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.banknoteValidator.disable();
 		
 	}
 	
-	
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 		Banknote banknote = new Banknote(currency, value);
 		boolean isValid = false;
@@ -34,7 +61,6 @@ public class BanknoteValidatorControlObserver implements BanknoteValidatorObserv
 			validator.accept(banknote);
 			isValid = true;
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		totalBanknotes++;
@@ -42,7 +68,23 @@ public class BanknoteValidatorControlObserver implements BanknoteValidatorObserv
 		
 	}
 	
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
 	public void invalidBanknoteDetected(BanknoteValidator validator) {
 		
+		Banknote banknote = new Banknote(cad, noteValue);
+		boolean isValid = false;
+		try {
+			validator.accept(banknote);
+			isValid = true;
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
 	}
 }
\ No newline at end of file
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index e25c137..8710f92 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -3,36 +3,54 @@ package org.control.software;
 import java.math.BigDecimal;
 
 import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
 
+/**
+ * Observes events emanating from a barcode scanner.
+ */
 public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	
 	private SelfCheckoutStation checkoutStation;
 	BigDecimal totalValue = new BigDecimal(0.0);
 	int totalItems;
-	//
-	@Override
+
+	/**
+	 * Enables barcode devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.scanner.enable();
 		
 	}
 
-	@Override
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.scanner.disable();
 		
 	}
 
-	@Override
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
 	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
 		
 		ProductsCollection products = new ProductsCollection();
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
index 063e22e..c0d5b11 100644
--- a/src/org/control/software/CoinStorageUnitControlObserver.java
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -92,15 +92,15 @@ public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 		
 	}
 
-	
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsUnloaded(CoinStorageUnit unit) {
-		/**
-		 * Announces that the storage unit has been emptied of coins. Used to
-		 * simulate direct, physical unloading of the unit.
-		 * 
-		 * @param unit
-		 *            The storage unit where the event occurred.
-		 */
+		
 		unit.unload();
 		
 	}
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 313e3bb..032a0de 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -2,7 +2,6 @@ package org.control.software;
 
 import java.util.HashMap;
 import java.util.Map;
-
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.SimulationException;
@@ -39,7 +38,5 @@ public class ItemsCollection extends Item {
 	public double getWeight() {
 		return weightInGrams;
 	}
-	
-	
 
 }
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index daa3cb4..af69e3d 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -10,6 +10,10 @@ import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 
 
+/**
+ * Simulates a products database.
+ *
+ */
 public class ProductsCollection {
 	
 	Map<Barcode, String> barcodesMap = new HashMap<Barcode, String>();
@@ -20,10 +24,17 @@ public class ProductsCollection {
 	Barcode milkBarcode;
 	Barcode riceBarcode;
 	
+	/**
+	 * Constructor that initializes products collection.
+	 */
 	public ProductsCollection() {
 		this.initializeProducts();
 	}
 	
+	
+	/**
+	 * Initializes products with barcodes, prices, and descriptions.
+	 */
 	public void initializeProducts() {
 		
 		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
@@ -45,12 +56,28 @@ public class ProductsCollection {
 		
 	}
 	
+	
+	/**
+	 * Gets a set of products and their barcodes.
+	 * 
+	 * @return barcodesMap set
+	 */
 	public Set<Entry<Barcode, String>> getProducts() {
 		
 		return barcodesMap.entrySet();
 		
 	}
 	
+	
+	/**
+	 * Gets price for a specified product.
+	 * 
+	 * @param barcode
+	 * 				Product barcode.
+	 * 
+	 * @return price
+	 * 				Price of product.
+	 */
 	public BigDecimal getPrice(Barcode barcode) {
 		
 		BigDecimal price = new BigDecimal("0.0");
@@ -63,6 +90,15 @@ public class ProductsCollection {
 		
 	}
 	
+	/**
+	 * Gets description for a specified product.
+	 * 
+	 * @param barcode
+	 * 				Product barcode.
+	 * 
+	 * @return description
+	 * 				Description of product.
+	 */
 	public String getDescription(Barcode barcode) {
 		
 		String description = "";
@@ -75,6 +111,12 @@ public class ProductsCollection {
 		
 	}
 	
+	/**
+	 * Gets all barcodes.
+	 * 
+	 * @return barcodesMap keys
+	 * 				All barcodes.
+	 */
 	public Set<Barcode> getBarcodes() {
 		return barcodesMap.keySet();
 	}

commit c7ae58c9a8828efa223e2878f8f1346d8235c3bf
Author: lime39 <bobj32258@gmail.com>
Date:   Sun Mar 20 14:08:48 2022 -0600

    Added comments to Coin Classes, changed name of project.

diff --git a/.project b/.project
index c81b915..f27f7cb 100644
--- a/.project
+++ b/.project
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SCS - Hardware - v1.0</name>
+	<name>SCS - Software</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -16,7 +16,7 @@
 	</natures>
 	<filteredResources>
 		<filter>
-			<id>1647639567535</id>
+			<id>0</id>
 			<name></name>
 			<type>30</type>
 			<matcher>
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
index cf8a67a..0fb7d28 100644
Binary files a/bin/org/control/software/CoinSlotControlObserver.class and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinStorageUnitControlObserver.class b/bin/org/control/software/CoinStorageUnitControlObserver.class
index 29b59cd..f88d114 100644
Binary files a/bin/org/control/software/CoinStorageUnitControlObserver.class and b/bin/org/control/software/CoinStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
index 62dacea..bfd2dc5 100644
Binary files a/bin/org/control/software/CoinTrayControlObserver.class and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 152be9c..430a55f 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
index 5a6954d..905e268 100644
--- a/src/org/control/software/CoinSlotControlObserver.java
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -10,6 +10,11 @@ import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinSlot;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
+/**
+ * Observes events emanating from a coin slot.
+ *
+ */
+
 public class CoinSlotControlObserver implements CoinSlotObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
@@ -17,11 +22,24 @@ public class CoinSlotControlObserver implements CoinSlotObserver{
 	BigDecimal coinValue;
 	
 	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinSlot.enable();
 	
 	}
+	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -29,13 +47,18 @@ public class CoinSlotControlObserver implements CoinSlotObserver{
 		
 	}
 	
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
 	public void coinInserted(CoinSlot slot) {
 		
 		Coin coin = new Coin(coinValue);
 		try {
 			slot.accept(coin);
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
index 2bd4673..063e22e 100644
--- a/src/org/control/software/CoinStorageUnitControlObserver.java
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -11,24 +11,44 @@ import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
 
+/**
+ * Observes events emanating from a coin storage unit.
+ *
+ */
 public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 
 	private SelfCheckoutStation checkoutStation;
 	boolean coinsFull;
 	BigDecimal coinValue;
 	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinStorage.enable();
 		
 	}
 
-	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinStorage.disable();
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsFull(CoinStorageUnit unit) {
 		
 		if (unit.getCoinCount() > unit.getCapacity()) {
@@ -37,7 +57,12 @@ public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 		
 	}
 
-	
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinAdded(CoinStorageUnit unit) {
 		
 		Coin coin = new Coin(coinValue);
@@ -49,7 +74,13 @@ public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsLoaded(CoinStorageUnit unit) {
 		
 		Coin coin = new Coin(coinValue);
@@ -63,8 +94,13 @@ public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 
 	
 	public void coinsUnloaded(CoinStorageUnit unit) {
-		
-		Coin coin = new Coin(coinValue);
+		/**
+		 * Announces that the storage unit has been emptied of coins. Used to
+		 * simulate direct, physical unloading of the unit.
+		 * 
+		 * @param unit
+		 *            The storage unit where the event occurred.
+		 */
 		unit.unload();
 		
 	}
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
index e9690e9..dce5107 100644
--- a/src/org/control/software/CoinTrayControlObserver.java
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -11,23 +11,45 @@ import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 
+/**
+ * Observes events emanating from a coin tray. 
+ * 
+ */
+
 public class CoinTrayControlObserver implements CoinTrayObserver {
 
 	private SelfCheckoutStation checkoutStation;
 	BigDecimal coinValue;
 	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.enable();
 		
 		
 	}
 
-	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.disable();
 		
 	}
 
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
 	public void coinAdded(CoinTray tray) {
 		
 		Coin coin = new Coin(coinValue);
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index 4980c4f..4de0cac 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -10,46 +10,74 @@ import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinValidator;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
+/**
+ * Observes events emanating from a coin validator.
+ */
 public class CoinValidatorControlObserver implements CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
 	int totalValue;
 	BigDecimal coinValue;
 
-	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinValidator.enable();
 	
 	}
 
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinValidator.disable();
 		
 	}
 	
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
 	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
 		coinValue = value;
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		totalCoins++;
 		totalValue += coinValue.intValue();
 	}
 	
-	@Override
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	
 	public void invalidCoinDetected(CoinValidator validator) {
 		boolean isValid = false;
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			isValid = true;
 			e.printStackTrace();
 		}

commit 5eafdbd749def9b6e5af52f7d4fbe8436f6b4d98
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 13:50:20 2022 -0600

    banknote storage done

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index aa1257b..5ec20f1 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteStorageUnitControlObserver.class b/bin/org/control/software/BanknoteStorageUnitControlObserver.class
index 8bd0bf4..e3b2324 100644
Binary files a/bin/org/control/software/BanknoteStorageUnitControlObserver.class and b/bin/org/control/software/BanknoteStorageUnitControlObserver.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index 6743968..f42b42f 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -35,9 +35,9 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 	
 	public void banknoteInserted(BanknoteSlot slot){
 		
-		Banknote bankNote = new Banknote(cad, noteValue);
+		Banknote banknote = new Banknote(cad, noteValue);
 		try {
-			slot.accept(bankNote);
+			slot.accept(banknote);
 		} catch (DisabledException | OverloadException e) {
 			e.printStackTrace();
 		}
diff --git a/src/org/control/software/BanknoteStorageUnitControlObserver.java b/src/org/control/software/BanknoteStorageUnitControlObserver.java
index a9ba907..cabc319 100644
--- a/src/org/control/software/BanknoteStorageUnitControlObserver.java
+++ b/src/org/control/software/BanknoteStorageUnitControlObserver.java
@@ -1,7 +1,13 @@
 package org.control.software;
 
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
@@ -9,6 +15,9 @@ import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
 public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitObserver {
 
 	private SelfCheckoutStation checkoutStation;
+	boolean banknotesFull;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -25,24 +34,42 @@ public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitOb
 	
 	public void banknotesFull(BanknoteStorageUnit unit) {
 		
+		if(unit.getBanknoteCount() > unit.getCapacity()) {
+			banknotesFull = true;
+		}
+		
 		
 	}
 
 	
 	public void banknoteAdded(BanknoteStorageUnit unit) {
 		
+		Banknote banknote = new Banknote(cad, noteValue);
+		try {
+			unit.accept(banknote);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
 		
 	}
 
 	
 	public void banknotesLoaded(BanknoteStorageUnit unit) {
 		
+		Banknote banknote = new Banknote(cad, noteValue);
+		try {
+			unit.load(banknote);
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
 		
 	}
 
 	
 	public void banknotesUnloaded(BanknoteStorageUnit unit) {
 		
+		Banknote banknote = new Banknote(cad, noteValue);
+		unit.unload();
 		
 	}
 

commit b39825c126a871fbe8e8c7c8edc55e864b0ea9a9
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 13:46:19 2022 -0600

    bank note slot done

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index 1e84350..aa1257b 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index cf4f8ec..6743968 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -3,13 +3,20 @@ import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+import java.util.Currency;
+
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 
 public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
 	int totalValue;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -28,10 +35,24 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
 	
 	public void banknoteInserted(BanknoteSlot slot){
 		
+		Banknote bankNote = new Banknote(cad, noteValue);
+		try {
+			slot.accept(bankNote);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
+		
 	}
 	
 	public void banknoteEjected(BanknoteSlot slot){
 		
+		Banknote bankNote = new Banknote(cad, noteValue);
+		try {
+			slot.emit(bankNote);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
 	}
 	
 	public void banknoteRemoved(BanknoteSlot slot){

commit 19f770d326022bc76fe981b8ceb0d102ab80f6ae
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 13:42:33 2022 -0600

    coin tray done done

diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
index 48c4845..62dacea 100644
Binary files a/bin/org/control/software/CoinTrayControlObserver.class and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
index 19b8254..e9690e9 100644
--- a/src/org/control/software/CoinTrayControlObserver.java
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -1,7 +1,12 @@
 package org.control.software;
 
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
@@ -9,6 +14,8 @@ import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 public class CoinTrayControlObserver implements CoinTrayObserver {
 
 	private SelfCheckoutStation checkoutStation;
+	BigDecimal coinValue;
+	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.enable();
 		
@@ -23,6 +30,12 @@ public class CoinTrayControlObserver implements CoinTrayObserver {
 
 	public void coinAdded(CoinTray tray) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			tray.accept(coin);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}	
 		
 	}
 

commit e277bf980c78c3d98784db18dc1634c6746527f5
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 13:41:15 2022 -0600

    coin tray done

diff --git a/bin/org/control/software/CoinStorageUnitControlObserver.class b/bin/org/control/software/CoinStorageUnitControlObserver.class
index 96e0ab4..29b59cd 100644
Binary files a/bin/org/control/software/CoinStorageUnitControlObserver.class and b/bin/org/control/software/CoinStorageUnitControlObserver.class differ
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
index fae8082..2bd4673 100644
--- a/src/org/control/software/CoinStorageUnitControlObserver.java
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -1,7 +1,12 @@
 package org.control.software;
 
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
@@ -9,6 +14,8 @@ import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
 public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 
 	private SelfCheckoutStation checkoutStation;
+	boolean coinsFull;
+	BigDecimal coinValue;
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinStorage.enable();
@@ -24,23 +31,41 @@ public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 	
 	public void coinsFull(CoinStorageUnit unit) {
 		
+		if (unit.getCoinCount() > unit.getCapacity()) {
+			coinsFull = true;
+		}
 		
 	}
 
 	
 	public void coinAdded(CoinStorageUnit unit) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			unit.accept(coin);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
 		
 	}
 
 	
 	public void coinsLoaded(CoinStorageUnit unit) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			unit.load(coin);
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+		
 	}
 
 	
 	public void coinsUnloaded(CoinStorageUnit unit) {
 		
+		Coin coin = new Coin(coinValue);
+		unit.unload();
 		
 	}
 

commit 35b31c1f09caf81dbc2a57062ee802e7d17f82d2
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 13:36:01 2022 -0600

    CoinSlot done

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
new file mode 100644
index 0000000..1e84350
Binary files /dev/null and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteStorageUnitControlObserver.class b/bin/org/control/software/BanknoteStorageUnitControlObserver.class
new file mode 100644
index 0000000..8bd0bf4
Binary files /dev/null and b/bin/org/control/software/BanknoteStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
new file mode 100644
index 0000000..6f886bc
Binary files /dev/null and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
index fde67aa..cf8a67a 100644
Binary files a/bin/org/control/software/CoinSlotControlObserver.class and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index b0d6311..b0493fc 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -29,8 +29,10 @@ public class BanknoteValidatorControlObserver implements BanknoteValidatorObserv
 	
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 		Banknote banknote = new Banknote(currency, value);
+		boolean isValid = false;
 		try {
 			validator.accept(banknote);
+			isValid = true;
 		} catch (DisabledException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
index a6a2075..5a6954d 100644
--- a/src/org/control/software/CoinSlotControlObserver.java
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -8,11 +8,13 @@ import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinSlot;
+import org.lsmr.selfcheckout.devices.DisabledException;
 
 public class CoinSlotControlObserver implements CoinSlotObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
 	int totalAmount;
+	BigDecimal coinValue;
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -27,7 +29,15 @@ public class CoinSlotControlObserver implements CoinSlotObserver{
 		
 	}
 	
-	public void coinInserted(CoinSlot slot){
+	public void coinInserted(CoinSlot slot) {
+		
+		Coin coin = new Coin(coinValue);
+		try {
+			slot.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 		
 	}
 }

commit cb37c588f22a5c2805551665dc46609cb474a5af
Author: lime39 <bobj32258@gmail.com>
Date:   Sat Mar 19 18:47:39 2022 -0600

    Removed BanknoteControlObserver, separated into 3 classes.

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
deleted file mode 100644
index a1d4899..0000000
Binary files a/bin/org/control/software/BanknoteControlObserver.class and /dev/null differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
new file mode 100644
index 0000000..cf4f8ec
--- /dev/null
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -0,0 +1,42 @@
+package org.control.software;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+public class BanknoteSlotControlObserver implements BanknoteSlotObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalBanknotes;
+	int totalValue;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.enable();
+		checkoutStation.banknoteOutput.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.disable();
+		checkoutStation.banknoteOutput.disable();
+		
+	}
+	
+	public void banknoteInserted(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteEjected(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteRemoved(BanknoteSlot slot){
+		slot.removeDanglingBanknote();
+		totalBanknotes--;
+		
+	}
+}
diff --git a/src/org/control/software/BanknoteStorageUnitControlObserver.java b/src/org/control/software/BanknoteStorageUnitControlObserver.java
new file mode 100644
index 0000000..a9ba907
--- /dev/null
+++ b/src/org/control/software/BanknoteStorageUnitControlObserver.java
@@ -0,0 +1,49 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteStorage.enable();
+	}
+
+	
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteStorage.disable();
+		
+	}
+
+	
+	public void banknotesFull(BanknoteStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void banknoteAdded(BanknoteStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void banknotesLoaded(BanknoteStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void banknotesUnloaded(BanknoteStorageUnit unit) {
+		
+		
+	}
+
+}
diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
similarity index 66%
rename from src/org/control/software/BanknoteControlObserver.java
rename to src/org/control/software/BanknoteValidatorControlObserver.java
index e016c05..b0d6311 100644
--- a/src/org/control/software/BanknoteControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -2,15 +2,13 @@ package org.control.software;
 import java.util.Currency;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
-public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
+public class BanknoteValidatorControlObserver implements BanknoteValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
 	int totalValue;
@@ -18,33 +16,16 @@ public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteVa
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
-		checkoutStation.banknoteInput.enable();
-		checkoutStation.banknoteOutput.enable();
 		checkoutStation.banknoteValidator.enable();
 	
 	}
 
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
-		checkoutStation.banknoteInput.disable();
-		checkoutStation.banknoteOutput.disable();
 		checkoutStation.banknoteValidator.disable();
 		
 	}
 	
-	public void banknoteInserted(BanknoteSlot slot){
-		
-	}
-	
-	public void banknoteEjected(BanknoteSlot slot){
-		
-	}
-	
-	public void banknoteRemoved(BanknoteSlot slot){
-		slot.removeDanglingBanknote();
-		totalBanknotes--;
-		
-	}
 	
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 		Banknote banknote = new Banknote(currency, value);

commit 935855a4f42df69bcdd48802fceb2b1c3381195d
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 17:38:32 2022 -0600

    fixed path

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index 0a51c71..e25c137 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -17,7 +17,7 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	private SelfCheckoutStation checkoutStation;
 	BigDecimal totalValue = new BigDecimal(0.0);
 	int totalItems;
-	
+	//
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		

commit 8a7582fac0509168f413d74ecdf386169ef4fb7d
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 16:34:12 2022 -0600

    removed CoinObserver and implemented invalidCoin

diff --git a/bin/org/control/software/CoinControlObserver.class b/bin/org/control/software/CoinControlObserver.class
deleted file mode 100644
index f13f7b8..0000000
Binary files a/bin/org/control/software/CoinControlObserver.class and /dev/null differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 28b7af7..152be9c 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/src/org/control/software/CoinControlObserver.java b/src/org/control/software/CoinControlObserver.java
deleted file mode 100644
index 3d38269..0000000
--- a/src/org/control/software/CoinControlObserver.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.control.software;
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
-import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinSlot;
-import org.lsmr.selfcheckout.devices.CoinValidator;
-import org.lsmr.selfcheckout.devices.DisabledException;
-
-public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObserver{
-	private SelfCheckoutStation checkoutStation;
-	int totalCoins;
-	int totalValue;
-	
-	
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		
-		checkoutStation.coinSlot.enable();
-		checkoutStation.coinValidator.enable();
-	
-	}
-
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		
-		checkoutStation.coinSlot.disable();
-		checkoutStation.coinValidator.disable();
-		
-	}
-	
-	public void coinInserted(CoinSlot slot){
-		
-	}
-	
-	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
-		Coin coin = new Coin(value);
-		try {
-			validator.accept(coin);
-		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		int coinValue = value.intValue();
-		totalCoins++;
-		totalValue += coinValue;
-	}
-	
-	public void invalidCoinDetected(CoinValidator validator) {
-		
-	}
-}
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index 5433f40..4980c4f 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -13,8 +13,9 @@ import org.lsmr.selfcheckout.devices.DisabledException;
 public class CoinValidatorControlObserver implements CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
-	int totalAmount;
-	
+	int totalValue;
+	BigDecimal coinValue;
+
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -24,22 +25,34 @@ public class CoinValidatorControlObserver implements CoinValidatorObserver{
 
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
-		checkoutStation.coinSlot.disable();
 		checkoutStation.coinValidator.disable();
 		
 	}
 	
 	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
-		Coin coin = new Coin(value);
+		coinValue = value;
+		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
 		} catch (DisabledException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
+		totalCoins++;
+		totalValue += coinValue.intValue();
 	}
 	
+	@Override
 	public void invalidCoinDetected(CoinValidator validator) {
+		boolean isValid = false;
+		Coin coin = new Coin(coinValue);
+		try {
+			validator.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			isValid = true;
+			e.printStackTrace();
+		}
 		
 	}
 }
\ No newline at end of file

commit e45617c8a451b98b0bc8ce538b9d96390786021e
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 16:19:16 2022 -0600

    fixed items collection

diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
index 2cc4444..509831c 100644
Binary files a/bin/org/control/software/BarcodeScannerControlObserver.class and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index ff7fbc9..4d5cbfc 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 6156c1f..096d87c 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index 8758f55..0a51c71 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -37,7 +37,8 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 		
 		ProductsCollection products = new ProductsCollection();
 		BigDecimal price = products.getPrice(barcode);
-		barcodeScanner.scan(null);
+		Item item = products.itemsMap.get(barcode);
+		barcodeScanner.scan(item);
 		totalItems++;
 		totalValue = totalValue.add(price);
 		
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 38971ed..313e3bb 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -1,13 +1,43 @@
 package org.control.software;
 
+import java.util.HashMap;
+import java.util.Map;
+
+import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.SimulationException;
 
 
 public class ItemsCollection extends Item {
+	
+	double weightInGrams;
+	
+	Map<Barcode, Double> weightsMap = new HashMap<Barcode, Double>();
 
-	protected ItemsCollection(double weightInGrams) {
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
 		super(weightInGrams);
-		// TODO Auto-generated constructor stub
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+		weightsMap.put(barcode, weightInGrams);
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
 	}
 	
 	
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 66dbd03..daa3cb4 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -6,6 +6,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 
 
@@ -14,6 +15,7 @@ public class ProductsCollection {
 	Map<Barcode, String> barcodesMap = new HashMap<Barcode, String>();
 	Map<Barcode, String> descriptionsMap = new HashMap<>();
 	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
+	Map<Barcode, ItemsCollection> itemsMap = new HashMap<Barcode, ItemsCollection>();
 	
 	Barcode milkBarcode;
 	Barcode riceBarcode;
@@ -38,6 +40,9 @@ public class ProductsCollection {
 		descriptionsMap.put(milkBarcode, "Drink");
 		descriptionsMap.put(riceBarcode, "Grains");
 		
+		itemsMap.put(milkBarcode, new ItemsCollection(milkBarcode, 1.00));
+		itemsMap.put(riceBarcode, new ItemsCollection(riceBarcode, 0.5));
+		
 	}
 	
 	public Set<Entry<Barcode, String>> getProducts() {

commit 1174cb2840ddb29847030a289ea0cb332cdc45a8
Author: lime39 <bobj32258@gmail.com>
Date:   Sat Mar 19 16:04:45 2022 -0600

    Added logic to valid methods in CoinControl and BanknoteControl.

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
index 0af3d12..a1d4899 100644
Binary files a/bin/org/control/software/BanknoteControlObserver.class and b/bin/org/control/software/BanknoteControlObserver.class differ
diff --git a/bin/org/control/software/CoinControlObserver.class b/bin/org/control/software/CoinControlObserver.class
index 9061903..f13f7b8 100644
Binary files a/bin/org/control/software/CoinControlObserver.class and b/bin/org/control/software/CoinControlObserver.class differ
diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteControlObserver.java
index ad01613..e016c05 100644
--- a/src/org/control/software/BanknoteControlObserver.java
+++ b/src/org/control/software/BanknoteControlObserver.java
@@ -13,6 +13,7 @@ import org.lsmr.selfcheckout.devices.DisabledException;
 public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
+	int totalValue;
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -53,6 +54,8 @@ public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteVa
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
+		totalBanknotes++;
+		totalValue += value;
 		
 	}
 	
diff --git a/src/org/control/software/CoinControlObserver.java b/src/org/control/software/CoinControlObserver.java
index 85842f4..3d38269 100644
--- a/src/org/control/software/CoinControlObserver.java
+++ b/src/org/control/software/CoinControlObserver.java
@@ -15,7 +15,7 @@ import org.lsmr.selfcheckout.devices.DisabledException;
 public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
-	int totalAmount;
+	int totalValue;
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -44,6 +44,9 @@ public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObser
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
+		int coinValue = value.intValue();
+		totalCoins++;
+		totalValue += coinValue;
 	}
 	
 	public void invalidCoinDetected(CoinValidator validator) {

commit c9b47de091718355f28f2788149638696ccc44c6
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 16:02:45 2022 -0600

    commit

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 60b6a5a..ff7fbc9 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 0a013ea..6156c1f 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 5825aff..38971ed 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -1,56 +1,15 @@
 package org.control.software;
 
-import java.math.BigDecimal;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
 import org.lsmr.selfcheckout.Item;
 
 
 public class ItemsCollection extends Item {
-	
+
 	protected ItemsCollection(double weightInGrams) {
 		super(weightInGrams);
 		// TODO Auto-generated constructor stub
 	}
-
-	Map<String, Double> weightsMap = new HashMap<>();
-	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
-	
-	public void initializeWeights() {
-		
-		weightsMap.put("Oranges", 0.25);
-		weightsMap.put("Chicken", 1.00);
-		
-	}
 	
-	public void initializePrices() {
-		
-		pricesMap.put("Oranges", new BigDecimal("0.99"));
-		pricesMap.put("Chicken", new BigDecimal("9.99"));
-		
-	}
 	
-	public Set<String> getItems() {
-		
-		return weightsMap.keySet();
-		
-	}
-	
-	public BigDecimal getPrice(String key) {
-		
-		BigDecimal price = new BigDecimal("0.0");
-		
-		if(pricesMap.containsKey(key)) {
-			price = pricesMap.get(key);
-		}
-		
-		return price;
-		
-	}
-	
-	public double getWeight(String key) {
-		return 0.0;
-	}
 
 }
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 00847df..66dbd03 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -15,6 +15,9 @@ public class ProductsCollection {
 	Map<Barcode, String> descriptionsMap = new HashMap<>();
 	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
 	
+	Barcode milkBarcode;
+	Barcode riceBarcode;
+	
 	public ProductsCollection() {
 		this.initializeProducts();
 	}
@@ -23,8 +26,8 @@ public class ProductsCollection {
 		
 		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
 		
-		Barcode milkBarcode = new Barcode(n);
-		Barcode riceBarcode = new Barcode(n);
+		milkBarcode = new Barcode(n);
+		riceBarcode = new Barcode(n);
 
 		barcodesMap.put(milkBarcode, "Carton of Milk");
 		barcodesMap.put(riceBarcode, "Bag of rice");

commit 420355a251188e3c100354b3b42f73292ffc6adb
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 15:52:25 2022 -0600

    changes to BarcodeScannerObserver

diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
index ee0d20a..2cc4444 100644
Binary files a/bin/org/control/software/BarcodeScannerControlObserver.class and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 59016a8..0a013ea 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index d3431ec..8758f55 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -1,5 +1,7 @@
 package org.control.software;
 
+import java.math.BigDecimal;
+
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
@@ -13,8 +15,9 @@ import org.lsmr.selfcheckout.products.BarcodedProduct;
 public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	
 	private SelfCheckoutStation checkoutStation;
+	BigDecimal totalValue = new BigDecimal(0.0);
 	int totalItems;
-// hello
+	
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -33,9 +36,10 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
 		
 		ProductsCollection products = new ProductsCollection();
-		
-		
+		BigDecimal price = products.getPrice(barcode);
+		barcodeScanner.scan(null);
 		totalItems++;
+		totalValue = totalValue.add(price);
 		
 	}
 
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 55c99eb..00847df 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -43,8 +43,7 @@ public class ProductsCollection {
 		
 	}
 	
-	@SuppressWarnings("unlikely-arg-type")
-	public BigDecimal getPrice(String barcode) {
+	public BigDecimal getPrice(Barcode barcode) {
 		
 		BigDecimal price = new BigDecimal("0.0");
 		
@@ -56,7 +55,7 @@ public class ProductsCollection {
 		
 	}
 	
-	public String getDescription(String barcode) {
+	public String getDescription(Barcode barcode) {
 		
 		String description = "";
 		
@@ -68,7 +67,7 @@ public class ProductsCollection {
 		
 	}
 	
-	public Set<Barcode> getBarcode(String barcode) {
+	public Set<Barcode> getBarcodes() {
 		return barcodesMap.keySet();
 	}
 

commit be91249298d013556aed5d75ef4c29144eab0150
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 15:39:08 2022 -0600

    updated ProductsCollection

diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
index 588fb96..ee0d20a 100644
Binary files a/bin/org/control/software/BarcodeScannerControlObserver.class and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 4302de2..59016a8 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index 457390e..d3431ec 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -34,10 +34,7 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 		
 		ProductsCollection products = new ProductsCollection();
 		
-		//BarcodedProduct bp = new BarcodedProduct(products.getBarcode("Milk"), products.getDescription("Milk"), products.getPrice("Milk"));
 		
-
-		//barcodeScanner.scan(bp);
 		totalItems++;
 		
 	}
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 81fe036..55c99eb 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -3,6 +3,7 @@ package org.control.software;
 import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Numeral;
@@ -10,74 +11,65 @@ import org.lsmr.selfcheckout.Numeral;
 
 public class ProductsCollection {
 	
-	Map<String, String> descriptionsMap = new HashMap<>();
-	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
-	Map<String, Barcode> barcodesMap = new HashMap<String, Barcode>();
+	Map<Barcode, String> barcodesMap = new HashMap<Barcode, String>();
+	Map<Barcode, String> descriptionsMap = new HashMap<>();
+	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
 	
 	public ProductsCollection() {
-		this.initializeDescriptions();
-		this.initializePrices();
-		this.initializeBarcodes();
+		this.initializeProducts();
 	}
 	
-	public void initializeDescriptions() {
-		
-		descriptionsMap.put("Carton of Milk", "Drink");
-		descriptionsMap.put("Bag of Rice", "Grains");
-		
-	}
-	
-	public void initializePrices() {
-		
-		pricesMap.put("Carton of Milk", new BigDecimal("2.99"));
-		pricesMap.put("Bag of Rice", new BigDecimal("4.99"));
-		
-	}
-	
-	public void initializeBarcodes() {
+	public void initializeProducts() {
 		
 		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
 		
 		Barcode milkBarcode = new Barcode(n);
 		Barcode riceBarcode = new Barcode(n);
 
-		barcodesMap.put("Carton of Milk", milkBarcode);
-		barcodesMap.put("Bag of Rice", riceBarcode);
+		barcodesMap.put(milkBarcode, "Carton of Milk");
+		barcodesMap.put(riceBarcode, "Bag of rice");
+		
+		pricesMap.put(milkBarcode, new BigDecimal("2.99"));
+		pricesMap.put(riceBarcode, new BigDecimal("4.99"));
+		
+		descriptionsMap.put(milkBarcode, "Drink");
+		descriptionsMap.put(riceBarcode, "Grains");
 		
 	}
 	
-	public Set<String> getProducts() {
+	public Set<Entry<Barcode, String>> getProducts() {
 		
-		return descriptionsMap.keySet();
+		return barcodesMap.entrySet();
 		
 	}
 	
-	public BigDecimal getPrice(String key) {
+	@SuppressWarnings("unlikely-arg-type")
+	public BigDecimal getPrice(String barcode) {
 		
 		BigDecimal price = new BigDecimal("0.0");
 		
-		if(pricesMap.containsKey(key)) {
-			price = pricesMap.get(key);
+		if(pricesMap.containsKey(barcode)) {
+			price = pricesMap.get(barcode);
 		}
 		
 		return price;
 		
 	}
 	
-	public String getDescription(String key) {
+	public String getDescription(String barcode) {
 		
 		String description = "";
 		
-		if(descriptionsMap.containsKey(key)) {
-			description = descriptionsMap.get(key);
+		if(descriptionsMap.containsKey(barcode)) {
+			description = descriptionsMap.get(barcode);
 		}
 		
 		return description;
 		
 	}
 	
-	public Barcode getBarcode(String key) {
-		return null;
+	public Set<Barcode> getBarcode(String barcode) {
+		return barcodesMap.keySet();
 	}
 
 }

commit b35ea9654a8bf072ed9bf23926b1dfa976145b2e
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 15:33:18 2022 -0600

    removed CheckoutSystemLogic class

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
index d8f1dde..0af3d12 100644
Binary files a/bin/org/control/software/BanknoteControlObserver.class and b/bin/org/control/software/BanknoteControlObserver.class differ
diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
deleted file mode 100644
index bd9fe42..0000000
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and /dev/null differ
diff --git a/bin/org/control/software/CoinControlObserver.class b/bin/org/control/software/CoinControlObserver.class
index 1c26dc7..9061903 100644
Binary files a/bin/org/control/software/CoinControlObserver.class and b/bin/org/control/software/CoinControlObserver.class differ
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
new file mode 100644
index 0000000..fde67aa
Binary files /dev/null and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinStorageUnitControlObserver.class b/bin/org/control/software/CoinStorageUnitControlObserver.class
new file mode 100644
index 0000000..96e0ab4
Binary files /dev/null and b/bin/org/control/software/CoinStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
new file mode 100644
index 0000000..48c4845
Binary files /dev/null and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
new file mode 100644
index 0000000..28b7af7
Binary files /dev/null and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 2fcb685..60b6a5a 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
deleted file mode 100644
index 92cab41..0000000
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.control.software;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
-import org.lsmr.selfcheckout.products.Product;
-
-public class CheckoutSystemLogic {
-	
-	// Initialization
-	Banknote bn = new Banknote(null, 0);					// TODO : Currently a placeholder, may need to change
-	private SelfCheckoutStation checkoutStation;
-	
-	int totalItems;
-	int itemsBagged;
-	int paymentTotal;
-	
-	// TODO : Fill out with logic, currently placeholder
-	// Used to instantiate a Self Checkout Station.
-	public CheckoutSystemLogic(SelfCheckoutStation chkout) {
-		checkoutStation = chkout;
-		
-		totalItems = 0;
-		itemsBagged = 0;
-		paymentTotal = 0;
-		
-	}
-	
-
-	// Customer scans an item
-	public void itemScanned() {
-		Barcode bc = new Barcode(null);
-		BarcodedProduct product = new BarcodedProduct(bc, null, null);
-		
-		BarcodedItem item = new BarcodedItem(product.getBarcode(), 0);
-		
-		checkoutStation.scanner.scan(item);
-		
-		totalItems++;
-		
-	}
-	
-	// Customer places item in bagging area
-	public void itemBagged() {
-		
-		Barcode bc = new Barcode(null);
-		BarcodedItem item = new BarcodedItem(bc, 0);
-		checkoutStation.scale.add(item);
-		
-	}
-	
-	// Customer wishes to checkout
-	public void checkout() {
-		
-		checkoutStation.printer.print('c');
-		
-	}
-	
-	// Customer pays with a coin
-	public void coinPayment() throws DisabledException {
-		
-		Coin c = new Coin(null);
-		checkoutStation.coinValidator.accept(c);
-		checkoutStation.coinSlot.accept(c);
-		
-	}
-	
-	// Customer pays with a banknote
-	public void banknotePayment() throws DisabledException, OverloadException {
-		
-		Banknote bn = new Banknote(null, 0);
-		checkoutStation.banknoteInput.accept(bn);
-		
-	}
-
-}
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 57b718d..5825aff 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -14,11 +14,14 @@ public class ItemsCollection extends Item {
 		// TODO Auto-generated constructor stub
 	}
 
-	Map<String, String> weightsMap = new HashMap<>();
+	Map<String, Double> weightsMap = new HashMap<>();
 	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
 	
 	public void initializeWeights() {
 		
+		weightsMap.put("Oranges", 0.25);
+		weightsMap.put("Chicken", 1.00);
+		
 	}
 	
 	public void initializePrices() {

commit e1f90a94a483cde7b7d17e8915f51d6de37dc81e
Author: lime39 <bobj32258@gmail.com>
Date:   Sat Mar 19 13:37:28 2022 -0600

    Added some logic to methods of BanknoteControlObserver and
    CoinControlObserver. Added separate classes which are
    CoinSlotControlObserver, CoinValidatorControlObserver,
    CoinTrayControlObserver and CoinStorageUnitControlObserver.

diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteControlObserver.java
index 86b1d76..ad01613 100644
--- a/src/org/control/software/BanknoteControlObserver.java
+++ b/src/org/control/software/BanknoteControlObserver.java
@@ -8,10 +8,11 @@ import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
 
 public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
-	int totalCoins;
+	int totalBanknotes;
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -39,11 +40,19 @@ public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteVa
 	}
 	
 	public void banknoteRemoved(BanknoteSlot slot){
+		slot.removeDanglingBanknote();
+		totalBanknotes--;
 		
 	}
 	
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
-		
+		Banknote banknote = new Banknote(currency, value);
+		try {
+			validator.accept(banknote);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 		
 	}
 	
diff --git a/src/org/control/software/CoinControlObserver.java b/src/org/control/software/CoinControlObserver.java
index 3cd3cf6..85842f4 100644
--- a/src/org/control/software/CoinControlObserver.java
+++ b/src/org/control/software/CoinControlObserver.java
@@ -1,5 +1,7 @@
 package org.control.software;
 import java.math.BigDecimal;
+import java.util.Currency;
+
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
@@ -8,10 +10,12 @@ import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinSlot;
 import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
 
 public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
+	int totalAmount;
 	
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
@@ -33,8 +37,13 @@ public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObser
 	}
 	
 	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
-		
-		
+		Coin coin = new Coin(value);
+		try {
+			validator.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 	}
 	
 	public void invalidCoinDetected(CoinValidator validator) {
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
new file mode 100644
index 0000000..a6a2075
--- /dev/null
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -0,0 +1,33 @@
+package org.control.software;
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+public class CoinSlotControlObserver implements CoinSlotObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	int totalAmount;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.disable();
+		
+	}
+	
+	public void coinInserted(CoinSlot slot){
+		
+	}
+}
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
new file mode 100644
index 0000000..fae8082
--- /dev/null
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -0,0 +1,47 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinStorage.enable();
+		
+	}
+
+	
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinStorage.disable();
+		
+	}
+
+	
+	public void coinsFull(CoinStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void coinAdded(CoinStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void coinsLoaded(CoinStorageUnit unit) {
+		
+	}
+
+	
+	public void coinsUnloaded(CoinStorageUnit unit) {
+		
+		
+	}
+
+}
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
new file mode 100644
index 0000000..19b8254
--- /dev/null
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -0,0 +1,29 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+public class CoinTrayControlObserver implements CoinTrayObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinTray.enable();
+		
+		
+	}
+
+	
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinTray.disable();
+		
+	}
+
+	public void coinAdded(CoinTray tray) {
+		
+		
+	}
+
+}
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
new file mode 100644
index 0000000..5433f40
--- /dev/null
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -0,0 +1,45 @@
+package org.control.software;
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
+
+public class CoinValidatorControlObserver implements CoinValidatorObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	int totalAmount;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinValidator.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.disable();
+		checkoutStation.coinValidator.disable();
+		
+	}
+	
+	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+		Coin coin = new Coin(value);
+		try {
+			validator.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+	
+	public void invalidCoinDetected(CoinValidator validator) {
+		
+	}
+}
\ No newline at end of file

commit fbffe9ca4d1c49e081651b8fa916de87cbad6c81
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 12:25:10 2022 -0600

    removed unused imports

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 7cc1ff1..2fcb685 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 3eeb33f..57b718d 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -4,7 +4,6 @@ import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Item;
 
 

commit 2854560210760a4291b5530187cd89e602813af9
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 12:24:34 2022 -0600

    added ItemsCollection

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
new file mode 100644
index 0000000..d8f1dde
Binary files /dev/null and b/bin/org/control/software/BanknoteControlObserver.class differ
diff --git a/bin/org/control/software/CoinControlObserver.class b/bin/org/control/software/CoinControlObserver.class
new file mode 100644
index 0000000..1c26dc7
Binary files /dev/null and b/bin/org/control/software/CoinControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
new file mode 100644
index 0000000..7cc1ff1
Binary files /dev/null and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index e835076..4302de2 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
new file mode 100644
index 0000000..3eeb33f
--- /dev/null
+++ b/src/org/control/software/ItemsCollection.java
@@ -0,0 +1,54 @@
+package org.control.software;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Item;
+
+
+public class ItemsCollection extends Item {
+	
+	protected ItemsCollection(double weightInGrams) {
+		super(weightInGrams);
+		// TODO Auto-generated constructor stub
+	}
+
+	Map<String, String> weightsMap = new HashMap<>();
+	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
+	
+	public void initializeWeights() {
+		
+	}
+	
+	public void initializePrices() {
+		
+		pricesMap.put("Oranges", new BigDecimal("0.99"));
+		pricesMap.put("Chicken", new BigDecimal("9.99"));
+		
+	}
+	
+	public Set<String> getItems() {
+		
+		return weightsMap.keySet();
+		
+	}
+	
+	public BigDecimal getPrice(String key) {
+		
+		BigDecimal price = new BigDecimal("0.0");
+		
+		if(pricesMap.containsKey(key)) {
+			price = pricesMap.get(key);
+		}
+		
+		return price;
+		
+	}
+	
+	public double getWeight(String key) {
+		return 0.0;
+	}
+
+}
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index eb46701..81fe036 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -5,6 +5,7 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Numeral;
 
 
 public class ProductsCollection {
@@ -21,28 +22,27 @@ public class ProductsCollection {
 	
 	public void initializeDescriptions() {
 		
-		descriptionsMap.put("Milk", "Drink");
-		descriptionsMap.put("Oranges", "Fruit");
-		descriptionsMap.put("Chicken", "Poultry");
-		descriptionsMap.put("Rice", "Grains");
+		descriptionsMap.put("Carton of Milk", "Drink");
+		descriptionsMap.put("Bag of Rice", "Grains");
 		
 	}
 	
 	public void initializePrices() {
 		
-		pricesMap.put("Milk", new BigDecimal("2.99"));
-		pricesMap.put("Oranges", new BigDecimal("0.99"));
-		pricesMap.put("Chicken", new BigDecimal("9.99"));
-		pricesMap.put("Rice", new BigDecimal("4.99"));
+		pricesMap.put("Carton of Milk", new BigDecimal("2.99"));
+		pricesMap.put("Bag of Rice", new BigDecimal("4.99"));
 		
 	}
 	
 	public void initializeBarcodes() {
+		
+		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+		
+		Barcode milkBarcode = new Barcode(n);
+		Barcode riceBarcode = new Barcode(n);
 
-		barcodesMap.put("Milk", getBarcode("Milk"));
-		barcodesMap.put("Oranges", getBarcode("Oranges"));
-		barcodesMap.put("Chicken", getBarcode("Chicken"));
-		barcodesMap.put("Rice", getBarcode("Rice"));
+		barcodesMap.put("Carton of Milk", milkBarcode);
+		barcodesMap.put("Bag of Rice", riceBarcode);
 		
 	}
 	

commit e031c75e7d0b86309885a523d6c6b43c5ed10c14
Author: lime39 <bobj32258@gmail.com>
Date:   Fri Mar 18 17:55:32 2022 -0600

    Added BanknoteControlObserver. Methods aren't complete.

diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteControlObserver.java
new file mode 100644
index 0000000..86b1d76
--- /dev/null
+++ b/src/org/control/software/BanknoteControlObserver.java
@@ -0,0 +1,53 @@
+package org.control.software;
+import java.util.Currency;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.enable();
+		checkoutStation.banknoteOutput.enable();
+		checkoutStation.banknoteValidator.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.disable();
+		checkoutStation.banknoteOutput.disable();
+		checkoutStation.banknoteValidator.disable();
+		
+	}
+	
+	public void banknoteInserted(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteEjected(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteRemoved(BanknoteSlot slot){
+		
+	}
+	
+	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		
+		
+	}
+	
+	public void invalidBanknoteDetected(BanknoteValidator validator) {
+		
+	}
+}
\ No newline at end of file

commit 4ff6be6febc930cf4efb714fd02cd9c8620dba30
Author: lime39 <bobj32258@gmail.com>
Date:   Fri Mar 18 17:28:41 2022 -0600

    Added CoinControlObservor. Methods aren't complete.

diff --git a/src/org/control/software/CoinControlObserver.java b/src/org/control/software/CoinControlObserver.java
new file mode 100644
index 0000000..3cd3cf6
--- /dev/null
+++ b/src/org/control/software/CoinControlObserver.java
@@ -0,0 +1,43 @@
+package org.control.software;
+import java.math.BigDecimal;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+public class CoinControlObserver implements CoinSlotObserver, CoinValidatorObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.enable();
+		checkoutStation.coinValidator.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.disable();
+		checkoutStation.coinValidator.disable();
+		
+	}
+	
+	public void coinInserted(CoinSlot slot){
+		
+	}
+	
+	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+		
+		
+	}
+	
+	public void invalidCoinDetected(CoinValidator validator) {
+		
+	}
+}

commit c2326c6721977e880bce1f5cd89b48fe4ff1838d
Author: Shahriar Bin Zaman <shahriarbin.zaman@gmail.com>
Date:   Fri Mar 18 16:10:40 2022 -0600

    test commit

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index a6a6ce7..457390e 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -14,7 +14,7 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	
 	private SelfCheckoutStation checkoutStation;
 	int totalItems;
-
+// hello
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		

commit 024904d1f69c963438ac9ecdf9a56fce5343fd2e
Author: Arhum Ladak <arhumladak@Arhums-MacBook-Air.local>
Date:   Fri Mar 18 15:59:13 2022 -0600

    test commit

diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 0ff0cb1..eb46701 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -4,7 +4,7 @@ import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import org.lsmr.selfcheckout.Barcode; // asasdsd
+import org.lsmr.selfcheckout.Barcode;
 
 
 public class ProductsCollection {

commit 62cd606b29a1dda8fee3d36455efeac589d90eb1
Author: Arhum Ladak <arhumladak@Arhums-MacBook-Air.local>
Date:   Fri Mar 18 15:42:18 2022 -0600

    test commit

diff --git a/.project b/.project
index fd60f0c..c81b915 100644
--- a/.project
+++ b/.project
@@ -14,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1647639567535</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/bin/.gitignore b/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/bin/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
new file mode 100644
index 0000000..588fb96
Binary files /dev/null and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
new file mode 100644
index 0000000..e835076
Binary files /dev/null and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index eb46701..0ff0cb1 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -4,7 +4,7 @@ import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Barcode; // asasdsd
 
 
 public class ProductsCollection {

commit 4c75b2539e65a3e977137975f7226a83a1ba15e9
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Fri Mar 18 14:56:41 2022 -0600

    added constructor and removed unused imports

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index cfa75e0..a6a6ce7 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -33,9 +33,6 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
 		
 		ProductsCollection products = new ProductsCollection();
-		products.initializeDescriptions();
-		products.initializePrices();
-		products.initializeBarcodes();
 		
 		//BarcodedProduct bp = new BarcodedProduct(products.getBarcode("Milk"), products.getDescription("Milk"), products.getPrice("Milk"));
 		
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index aed55a2..eb46701 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -4,9 +4,8 @@ import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-
 import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.Numeral;
+
 
 public class ProductsCollection {
 	
@@ -14,6 +13,12 @@ public class ProductsCollection {
 	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
 	Map<String, Barcode> barcodesMap = new HashMap<String, Barcode>();
 	
+	public ProductsCollection() {
+		this.initializeDescriptions();
+		this.initializePrices();
+		this.initializeBarcodes();
+	}
+	
 	public void initializeDescriptions() {
 		
 		descriptionsMap.put("Milk", "Drink");

commit 3b6989501eab67b6951c9f707c70a35949c09d7c
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Fri Mar 18 13:05:42 2022 -0600

    commented out code with errors

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index 77aa0f9..cfa75e0 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -37,10 +37,10 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 		products.initializePrices();
 		products.initializeBarcodes();
 		
-		BarcodedProduct bp = new BarcodedProduct(products.getBarcode("Milk"), products.getDescription("Milk"), products.getPrice("Milk));
+		//BarcodedProduct bp = new BarcodedProduct(products.getBarcode("Milk"), products.getDescription("Milk"), products.getPrice("Milk"));
 		
 
-		barcodeScanner.scan(bp);
+		//barcodeScanner.scan(bp);
 		totalItems++;
 		
 	}

commit e5b9464a5e4cddbc68f277fb65b4a5adff9b1f14
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Fri Mar 18 13:05:00 2022 -0600

    updated ProductsCollection

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index b816760..77aa0f9 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -2,6 +2,7 @@ package org.control.software;
 
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -31,10 +32,15 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	@Override
 	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
 		
-		BarcodedProduct product = new BarcodedProduct(barcode, null, null);
-		product.getPrice();
-		BarcodedItem item = new BarcodedItem(product.getBarcode(), 0);
-		barcodeScanner.scan(item);
+		ProductsCollection products = new ProductsCollection();
+		products.initializeDescriptions();
+		products.initializePrices();
+		products.initializeBarcodes();
+		
+		BarcodedProduct bp = new BarcodedProduct(products.getBarcode("Milk"), products.getDescription("Milk"), products.getPrice("Milk));
+		
+
+		barcodeScanner.scan(bp);
 		totalItems++;
 		
 	}
diff --git a/src/org/control/software/Products.java b/src/org/control/software/Products.java
deleted file mode 100644
index 215f778..0000000
--- a/src/org/control/software/Products.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.control.software;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-public class Products {
-	
-	Map<String, String> mapDescription = new HashMap<>();
-	Map<String, Double> mapPrice = new HashMap<String, Double>();
-	
-	public void initializeDescriptions() {
-		
-		// "product", "description"
-		mapDescription.put("Milk", "Drink");
-		mapDescription.put("Oranges", "Fruit");
-		mapDescription.put("Chicken", "Poultry");
-		mapDescription.put("Rice", "Grains");
-		
-	}
-	
-	public void initializePrices() {
-		
-		// "product", "description"
-		mapPrice.put("Milk", 2.99);
-		mapPrice.put("Oranges", 0.99);
-		mapPrice.put("Chicken", 9.99);
-		mapPrice.put("Rice", 4.99);
-		
-	}
-	
-	public Set<String> getProducts() {
-		
-		return mapDescription.keySet();
-		
-	}
-	
-	public Double getPrice(String key) {
-		
-		Double price = 0.0;
-		
-		if(mapPrice.containsKey(key)) {
-			price = mapPrice.get(key);
-		}
-		
-		return price;
-		
-	}
-	
-	public String getDescription(String key) {
-		
-		String description = "";
-		
-		if(mapDescription.containsKey(key)) {
-			description = mapDescription.get(key);
-		}
-		
-		return description;
-		
-	}
-
-}
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
new file mode 100644
index 0000000..aed55a2
--- /dev/null
+++ b/src/org/control/software/ProductsCollection.java
@@ -0,0 +1,78 @@
+package org.control.software;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Numeral;
+
+public class ProductsCollection {
+	
+	Map<String, String> descriptionsMap = new HashMap<>();
+	Map<String, BigDecimal> pricesMap = new HashMap<String, BigDecimal>();
+	Map<String, Barcode> barcodesMap = new HashMap<String, Barcode>();
+	
+	public void initializeDescriptions() {
+		
+		descriptionsMap.put("Milk", "Drink");
+		descriptionsMap.put("Oranges", "Fruit");
+		descriptionsMap.put("Chicken", "Poultry");
+		descriptionsMap.put("Rice", "Grains");
+		
+	}
+	
+	public void initializePrices() {
+		
+		pricesMap.put("Milk", new BigDecimal("2.99"));
+		pricesMap.put("Oranges", new BigDecimal("0.99"));
+		pricesMap.put("Chicken", new BigDecimal("9.99"));
+		pricesMap.put("Rice", new BigDecimal("4.99"));
+		
+	}
+	
+	public void initializeBarcodes() {
+
+		barcodesMap.put("Milk", getBarcode("Milk"));
+		barcodesMap.put("Oranges", getBarcode("Oranges"));
+		barcodesMap.put("Chicken", getBarcode("Chicken"));
+		barcodesMap.put("Rice", getBarcode("Rice"));
+		
+	}
+	
+	public Set<String> getProducts() {
+		
+		return descriptionsMap.keySet();
+		
+	}
+	
+	public BigDecimal getPrice(String key) {
+		
+		BigDecimal price = new BigDecimal("0.0");
+		
+		if(pricesMap.containsKey(key)) {
+			price = pricesMap.get(key);
+		}
+		
+		return price;
+		
+	}
+	
+	public String getDescription(String key) {
+		
+		String description = "";
+		
+		if(descriptionsMap.containsKey(key)) {
+			description = descriptionsMap.get(key);
+		}
+		
+		return description;
+		
+	}
+	
+	public Barcode getBarcode(String key) {
+		return null;
+	}
+
+}

commit 214ac7abdd47a4244e283438e14da8eb191dab96
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Fri Mar 18 11:43:34 2022 -0600

    added products collection class

diff --git a/src/org/control/software/Products.java b/src/org/control/software/Products.java
new file mode 100644
index 0000000..215f778
--- /dev/null
+++ b/src/org/control/software/Products.java
@@ -0,0 +1,62 @@
+package org.control.software;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class Products {
+	
+	Map<String, String> mapDescription = new HashMap<>();
+	Map<String, Double> mapPrice = new HashMap<String, Double>();
+	
+	public void initializeDescriptions() {
+		
+		// "product", "description"
+		mapDescription.put("Milk", "Drink");
+		mapDescription.put("Oranges", "Fruit");
+		mapDescription.put("Chicken", "Poultry");
+		mapDescription.put("Rice", "Grains");
+		
+	}
+	
+	public void initializePrices() {
+		
+		// "product", "description"
+		mapPrice.put("Milk", 2.99);
+		mapPrice.put("Oranges", 0.99);
+		mapPrice.put("Chicken", 9.99);
+		mapPrice.put("Rice", 4.99);
+		
+	}
+	
+	public Set<String> getProducts() {
+		
+		return mapDescription.keySet();
+		
+	}
+	
+	public Double getPrice(String key) {
+		
+		Double price = 0.0;
+		
+		if(mapPrice.containsKey(key)) {
+			price = mapPrice.get(key);
+		}
+		
+		return price;
+		
+	}
+	
+	public String getDescription(String key) {
+		
+		String description = "";
+		
+		if(mapDescription.containsKey(key)) {
+			description = mapDescription.get(key);
+		}
+		
+		return description;
+		
+	}
+
+}

commit c940e371e2732d8033d1e7e9d5092d72a0426b5d
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Thu Mar 17 14:08:25 2022 -0600

    added disable to BarcodeScannerControlObserver

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index e091e0a..b816760 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -23,7 +23,8 @@ public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 
 	@Override
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
+		
+		checkoutStation.scanner.disable();
 		
 	}
 

commit 04dcfdaa419c2ad263df83e1376daa3ae646103f
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Thu Mar 17 14:04:55 2022 -0600

    added BarcodeScannerControlObserver

diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
new file mode 100644
index 0000000..e091e0a
--- /dev/null
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -0,0 +1,41 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+
+public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
+	
+	private SelfCheckoutStation checkoutStation;
+	int totalItems;
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.scanner.enable();
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
+		
+		BarcodedProduct product = new BarcodedProduct(barcode, null, null);
+		product.getPrice();
+		BarcodedItem item = new BarcodedItem(product.getBarcode(), 0);
+		barcodeScanner.scan(item);
+		totalItems++;
+		
+	}
+
+}

commit 0b81559b8bfb7030b37686c01a5b4d517f236868
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Wed Mar 16 17:10:28 2022 -0600

    fixed typo

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 974f433..bd9fe42 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 21bcc6b..92cab41 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -1,9 +1,12 @@
 package org.control.software;
 
+import java.util.ArrayList;
+
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -34,7 +37,6 @@ public class CheckoutSystemLogic {
 
 	// Customer scans an item
 	public void itemScanned() {
-		
 		Barcode bc = new Barcode(null);
 		BarcodedProduct product = new BarcodedProduct(bc, null, null);
 		

commit 745ee25eef1dad6ae3bbfad581fdb86972a529eb
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Wed Mar 16 16:56:40 2022 -0600

    added item counters

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index cc8e96b..974f433 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 8f85b4e..21bcc6b 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -7,6 +7,8 @@ import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+import org.lsmr.selfcheckout.products.Product;
 
 public class CheckoutSystemLogic {
 	
@@ -14,10 +16,19 @@ public class CheckoutSystemLogic {
 	Banknote bn = new Banknote(null, 0);					// TODO : Currently a placeholder, may need to change
 	private SelfCheckoutStation checkoutStation;
 	
+	int totalItems;
+	int itemsBagged;
+	int paymentTotal;
+	
 	// TODO : Fill out with logic, currently placeholder
 	// Used to instantiate a Self Checkout Station.
 	public CheckoutSystemLogic(SelfCheckoutStation chkout) {
 		checkoutStation = chkout;
+		
+		totalItems = 0;
+		itemsBagged = 0;
+		paymentTotal = 0;
+		
 	}
 	
 
@@ -25,9 +36,13 @@ public class CheckoutSystemLogic {
 	public void itemScanned() {
 		
 		Barcode bc = new Barcode(null);
-		BarcodedItem item = new BarcodedItem(bc, 0);
-	
-		checkoutStation.scanner.scan(item);;
+		BarcodedProduct product = new BarcodedProduct(bc, null, null);
+		
+		BarcodedItem item = new BarcodedItem(product.getBarcode(), 0);
+		
+		checkoutStation.scanner.scan(item);
+		
+		totalItems++;
 		
 	}
 	

commit de42075083adc648f0c999bcce2299c21b674ca9
Author: lime39 <bobj32258@gmail.com>
Date:   Tue Mar 15 13:53:15 2022 -0600

    Added logic to coinPayment()

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 8e9d8b7..cc8e96b 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index bb326ba..8f85b4e 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -3,6 +3,7 @@ package org.control.software;
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -47,7 +48,11 @@ public class CheckoutSystemLogic {
 	}
 	
 	// Customer pays with a coin
-	public void coinPayment() {
+	public void coinPayment() throws DisabledException {
+		
+		Coin c = new Coin(null);
+		checkoutStation.coinValidator.accept(c);
+		checkoutStation.coinSlot.accept(c);
 		
 	}
 	

commit 7cecd736644ee0f4459962f0e6ce4d00e2197a33
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:16:09 2022 -0600

    removed unused imports

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 17ac33f..8e9d8b7 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index ab2653a..bb326ba 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -3,13 +3,9 @@ package org.control.software;
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
-import org.lsmr.selfcheckout.products.Product;
 
 public class CheckoutSystemLogic {
 	

commit 934f4462e414906470f97337ecdae18a16894534
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:12:48 2022 -0600

    added initial itemBagged logic

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index f3992e0..17ac33f 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 9b0c241..ab2653a 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -37,6 +37,7 @@ public class CheckoutSystemLogic {
 	// Customer places item in bagging area
 	public void itemBagged() {
 		
+		Barcode bc = new Barcode(null);
 		BarcodedItem item = new BarcodedItem(bc, 0);
 		checkoutStation.scale.add(item);
 		

commit 06caeef918878a6e74c786dd7634be96950358f9
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:12:28 2022 -0600

    added initial itemBagged logic

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 77dc4fc..f3992e0 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 3c46722..9b0c241 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -37,11 +37,16 @@ public class CheckoutSystemLogic {
 	// Customer places item in bagging area
 	public void itemBagged() {
 		
+		BarcodedItem item = new BarcodedItem(bc, 0);
+		checkoutStation.scale.add(item);
+		
 	}
 	
 	// Customer wishes to checkout
 	public void checkout() {
 		
+		checkoutStation.printer.print('c');
+		
 	}
 	
 	// Customer pays with a coin

commit c50eb755ccc2c1c94769e63e924f8403dd10ca3b
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:11:09 2022 -0600

    added initial banknotePayment logic

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 349699f..77dc4fc 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index ecf3cd1..3c46722 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -4,6 +4,8 @@ import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
 import org.lsmr.selfcheckout.products.BarcodedProduct;
@@ -48,10 +50,10 @@ public class CheckoutSystemLogic {
 	}
 	
 	// Customer pays with a banknote
-	public void banknotePayment() {
+	public void banknotePayment() throws DisabledException, OverloadException {
 		
 		Banknote bn = new Banknote(null, 0);
-		
+		checkoutStation.banknoteInput.accept(bn);
 		
 	}
 

commit d09fe50d9f620a33d899bd72ef6f195750c56639
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:09:59 2022 -0600

    modified itemScanned logic

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 68797c6..349699f 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 7ec0fce..ecf3cd1 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -7,6 +7,7 @@ import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
 import org.lsmr.selfcheckout.products.BarcodedProduct;
+import org.lsmr.selfcheckout.products.Product;
 
 public class CheckoutSystemLogic {
 	
@@ -26,9 +27,8 @@ public class CheckoutSystemLogic {
 		
 		Barcode bc = new Barcode(null);
 		BarcodedItem item = new BarcodedItem(bc, 0);
-		BarcodeScanner scanner = new BarcodeScanner();
-		
-		scanner.scan(item);
+	
+		checkoutStation.scanner.scan(item);;
 		
 	}
 	
@@ -50,6 +50,9 @@ public class CheckoutSystemLogic {
 	// Customer pays with a banknote
 	public void banknotePayment() {
 		
+		Banknote bn = new Banknote(null, 0);
+		
+		
 	}
 
 }

commit 42dc16cfd3e2e25c7ad36464c3b77b00f89da7b8
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Tue Mar 15 12:06:47 2022 -0600

    added initial logic for itemScanned

diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index 337f50b..68797c6 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index e0b758a..7ec0fce 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -1,7 +1,12 @@
 package org.control.software;
 
 import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
 
 public class CheckoutSystemLogic {
 	
@@ -19,6 +24,12 @@ public class CheckoutSystemLogic {
 	// Customer scans an item
 	public void itemScanned() {
 		
+		Barcode bc = new Barcode(null);
+		BarcodedItem item = new BarcodedItem(bc, 0);
+		BarcodeScanner scanner = new BarcodeScanner();
+		
+		scanner.scan(item);
+		
 	}
 	
 	// Customer places item in bagging area

commit 40eeaa15014c1476621ce378dd6f1cf8a31db18e
Author: staytheknight <staytheknight@gmail.com>
Date:   Mon Mar 14 14:54:20 2022 -0600

    Added CheckoutSystemLogic instantiation method

diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1 @@
+/org/
diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
index cd5f48e..337f50b 100644
Binary files a/bin/org/control/software/CheckoutSystemLogic.class and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
index 8d0eb77..e0b758a 100644
--- a/src/org/control/software/CheckoutSystemLogic.java
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -1,11 +1,21 @@
 package org.control.software;
 
 import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 
 public class CheckoutSystemLogic {
 	
-	Banknote bn = new Banknote(null, 0);
+	// Initialization
+	Banknote bn = new Banknote(null, 0);					// TODO : Currently a placeholder, may need to change
+	private SelfCheckoutStation checkoutStation;
 	
+	// TODO : Fill out with logic, currently placeholder
+	// Used to instantiate a Self Checkout Station.
+	public CheckoutSystemLogic(SelfCheckoutStation chkout) {
+		checkoutStation = chkout;
+	}
+	
+
 	// Customer scans an item
 	public void itemScanned() {
 		

commit 8c9453ebe91b5a3d8a56614fa1c7cceccb3b6289
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Mon Mar 14 14:48:02 2022 -0600

    consolidated classes into logic class and added method stubs

diff --git a/bin/.gitignore b/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/bin/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/bin/org/control/software/Checkout.class b/bin/org/control/software/Checkout.class
deleted file mode 100644
index 994c897..0000000
Binary files a/bin/org/control/software/Checkout.class and /dev/null differ
diff --git a/bin/org/control/software/CheckoutSystemLogic.class b/bin/org/control/software/CheckoutSystemLogic.class
new file mode 100644
index 0000000..cd5f48e
Binary files /dev/null and b/bin/org/control/software/CheckoutSystemLogic.class differ
diff --git a/bin/org/control/software/Payment.class b/bin/org/control/software/Payment.class
deleted file mode 100644
index dae8544..0000000
Binary files a/bin/org/control/software/Payment.class and /dev/null differ
diff --git a/bin/org/control/software/Scan.class b/bin/org/control/software/Scan.class
deleted file mode 100644
index 2b1bad2..0000000
Binary files a/bin/org/control/software/Scan.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..de514e7
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..a9314d0
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..4c8882f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..aba29ee
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/src/org/control/software/Checkout.java b/src/org/control/software/Checkout.java
deleted file mode 100644
index c821f09..0000000
--- a/src/org/control/software/Checkout.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.control.software;
-
-public class Checkout {
-	
-	public void checkout() {
-		
-	}
-	
-}
diff --git a/src/org/control/software/CheckoutSystemLogic.java b/src/org/control/software/CheckoutSystemLogic.java
new file mode 100644
index 0000000..8d0eb77
--- /dev/null
+++ b/src/org/control/software/CheckoutSystemLogic.java
@@ -0,0 +1,34 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.Banknote;
+
+public class CheckoutSystemLogic {
+	
+	Banknote bn = new Banknote(null, 0);
+	
+	// Customer scans an item
+	public void itemScanned() {
+		
+	}
+	
+	// Customer places item in bagging area
+	public void itemBagged() {
+		
+	}
+	
+	// Customer wishes to checkout
+	public void checkout() {
+		
+	}
+	
+	// Customer pays with a coin
+	public void coinPayment() {
+		
+	}
+	
+	// Customer pays with a banknote
+	public void banknotePayment() {
+		
+	}
+
+}
diff --git a/src/org/control/software/Payment.java b/src/org/control/software/Payment.java
deleted file mode 100644
index a131ccf..0000000
--- a/src/org/control/software/Payment.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.control.software;
-
-import org.lsmr.selfcheckout.Banknote;
-
-public class Payment {
-	
-	Banknote bn = new Banknote(null, 0);
-	
-	public void payWithCoin() {
-		
-	}
-	
-	public void payWithBanknote() {
-		
-	}
-
-}
diff --git a/src/org/control/software/Scan.java b/src/org/control/software/Scan.java
deleted file mode 100644
index 2587fe8..0000000
--- a/src/org/control/software/Scan.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.control.software;
-
-public class Scan {
-	
-	public void itemScanned() {
-		
-	}
-	
-	public void itemBagged() {
-		
-	}
-
-}

commit dc4d8e4f293ed32447a9515147295d15235c57cd
Author: staytheknight <staytheknight@gmail.com>
Date:   Mon Mar 14 14:05:55 2022 -0600

    Fixed classpath errors & imported project source

diff --git a/.classpath b/.classpath
index d58936f..04cc82d 100644
--- a/.classpath
+++ b/.classpath
@@ -1,11 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-15">
-		<attributes>
-			<attribute name="module" value="true"/>
-		</attributes>
-	</classpathentry>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/.project b/.project
index 711bba8..fd60f0c 100644
--- a/.project
+++ b/.project
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SCS - Software</name>
+	<name>SCS - Hardware - v1.0</name>
 	<comment></comment>
 	<projects>
 	</projects>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
index 223b166..3a21537 100644
--- a/.settings/org.eclipse.jdt.core.prefs
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -1,14 +1,11 @@
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=15
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=15
+org.eclipse.jdt.core.compiler.compliance=1.8
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=enabled
-org.eclipse.jdt.core.compiler.source=15
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1 @@
+/org/
diff --git a/bin/org/control/software/Checkout.class b/bin/org/control/software/Checkout.class
index c48326d..994c897 100644
Binary files a/bin/org/control/software/Checkout.class and b/bin/org/control/software/Checkout.class differ
diff --git a/bin/org/control/software/Payment.class b/bin/org/control/software/Payment.class
index 214152d..dae8544 100644
Binary files a/bin/org/control/software/Payment.class and b/bin/org/control/software/Payment.class differ
diff --git a/bin/org/control/software/Scan.class b/bin/org/control/software/Scan.class
index 60b7b05..2b1bad2 100644
Binary files a/bin/org/control/software/Scan.class and b/bin/org/control/software/Scan.class differ
diff --git a/src/org/control/software/Checkout.java b/src/org/control/software/Checkout.java
index b92be6e..c821f09 100644
--- a/src/org/control/software/Checkout.java
+++ b/src/org/control/software/Checkout.java
@@ -5,5 +5,5 @@ public class Checkout {
 	public void checkout() {
 		
 	}
-
+	
 }
diff --git a/src/org/lsmr/selfcheckout/Banknote.java b/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..f91d858
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Banknote.java
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/Barcode.java b/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b8e1f7c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Barcode.java
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/src/org/lsmr/selfcheckout/BarcodedItem.java b/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..fab9792
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BarcodedItem.java
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/BlockedCardException.java b/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..3b6416e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BlockedCardException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Card.java b/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..58da94a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Card.java
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/ChipFailureException.java b/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..00c7c18
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/ChipFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Coin.java b/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..ede38a9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Coin.java
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/IllegalDigitException.java b/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..22e6f63
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/IllegalDigitException.java
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/InvalidPINException.java b/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..7134225
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/InvalidPINException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Item.java b/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..24e2842
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Item.java
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..fc5396e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Numeral.java b/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..c53e6f7
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Numeral.java
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/PLUCodedItem.java b/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..e0985d0
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/PLUCodedItem.java
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/PriceLookupCode.java b/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..c860edc
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/PriceLookupCode.java
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/TapFailureException.java b/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..66ea14e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/TapFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..20cb12a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Acceptor.java b/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..d3890b1
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Acceptor.java
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..df4e37e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..e8f30e4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..d773a2b
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..fc32c76
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..7e926a5
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..433dc07
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CardReader.java b/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..6f54d0d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CardReader.java
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..838766e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..9cc3516
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..97d5929
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinTray.java b/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..3ee4da7
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinTray.java
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..f444162
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/DisabledException.java b/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..7fce25d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/DisabledException.java
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..f6c0b47
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Emitter.java b/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..e4942a1
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Emitter.java
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/src/org/lsmr/selfcheckout/devices/EmptyException.java b/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..f8564db
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/EmptyException.java
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..089d324
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..5fb3376
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/OverloadException.java b/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..7fcc01d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/OverloadException.java
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..e1c16e6
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..0356dd2
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
@@ -0,0 +1,257 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>one scanner;</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale scale;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner scanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		scanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		scale.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		scanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/SimulationException.java b/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..7001f20
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/SimulationException.java
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..888ab32
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..5faa152
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..08d8fcd
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..f690ec9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..d4087a5
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..d63191a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..e3945d0
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..173be6c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..2494e38
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..75900f2
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..4c6f974
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..5a67bb4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..7229824
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..dcbdb49
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..16e810f
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..d630fea
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..794b53a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.barcode = barcode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..ef28888
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/products/Product.java b/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..cd7ccb4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/Product.java
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}

commit 4f8c7e2ea2dffe661521860614d96e1efe828a08
Author: staytheknight <staytheknight@gmail.com>
Date:   Mon Mar 14 13:55:04 2022 -0600

    Revert "Added project source code to be worked from"
    
    This reverts commit ef5f15bbff4c2e58fe5c06cd234154c9237d09d9.

diff --git a/.classpath b/.classpath
index fdd2993..d58936f 100644
--- a/.classpath
+++ b/.classpath
@@ -6,7 +6,6 @@
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
 	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v1.0/.classpath
deleted file mode 100644
index 04cc82d..0000000
--- a/SCS - Hardware - v1.0/.classpath	
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v1.0/.project
deleted file mode 100644
index fd60f0c..0000000
--- a/SCS - Hardware - v1.0/.project	
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SCS - Hardware - v1.0</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 3a21537..0000000
--- a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs	
+++ /dev/null
@@ -1,11 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.8
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class
deleted file mode 100644
index fbc21cf..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class
deleted file mode 100644
index 5cea197..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
deleted file mode 100644
index 2d68447..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
deleted file mode 100644
index 536dd3d..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class
deleted file mode 100644
index 795e5b4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
deleted file mode 100644
index a2d7141..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
deleted file mode 100644
index a72d8a2..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
deleted file mode 100644
index 8efccff..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class
deleted file mode 100644
index 262b944..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
deleted file mode 100644
index fa389c2..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class
deleted file mode 100644
index 67690f1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
deleted file mode 100644
index be8be69..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
deleted file mode 100644
index c08cda6..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class
deleted file mode 100644
index 69e38c1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
deleted file mode 100644
index 0f8b1e6..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class
deleted file mode 100644
index ac8cc6e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
deleted file mode 100644
index 941940c..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
deleted file mode 100644
index 0884227..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class
deleted file mode 100644
index 8d9b145..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
deleted file mode 100644
index 1dae3ed..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
deleted file mode 100644
index aff6c5e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
deleted file mode 100644
index 9043506..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
deleted file mode 100644
index a829b5d..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
deleted file mode 100644
index f18b4a4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
deleted file mode 100644
index 21d4eff..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
deleted file mode 100644
index a42c54f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
deleted file mode 100644
index 093246f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
deleted file mode 100644
index 8ae0603..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
deleted file mode 100644
index 1a090b0..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
deleted file mode 100644
index d069691..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
deleted file mode 100644
index db8f809..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
deleted file mode 100644
index db1e2c4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
deleted file mode 100644
index 6f49c78..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
deleted file mode 100644
index de514e7..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
deleted file mode 100644
index 5c66261..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
deleted file mode 100644
index a9314d0..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
deleted file mode 100644
index b23e858..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
deleted file mode 100644
index dc98a0f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
deleted file mode 100644
index 7db53cc..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
deleted file mode 100644
index bc15cfc..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
deleted file mode 100644
index ce0e2cd..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
deleted file mode 100644
index 4db506b..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
deleted file mode 100644
index 4c8882f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
deleted file mode 100644
index d616ae5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
deleted file mode 100644
index 964485e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
deleted file mode 100644
index 3b3f3af..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
deleted file mode 100644
index ef277e1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
deleted file mode 100644
index 8fa6c54..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
deleted file mode 100644
index dbec2ad..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
deleted file mode 100644
index b779d7e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
deleted file mode 100644
index 3ef8e5f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
deleted file mode 100644
index 21606de..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
deleted file mode 100644
index 7910341..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
deleted file mode 100644
index bd71242..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
deleted file mode 100644
index b922285..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
deleted file mode 100644
index 1391af5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
deleted file mode 100644
index b11003b..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
deleted file mode 100644
index 6bf0d70..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
deleted file mode 100644
index 9cd53cf..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
deleted file mode 100644
index ef726bb..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
deleted file mode 100644
index aba29ee..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
deleted file mode 100644
index 80746e5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class
deleted file mode 100644
index b3888c1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
deleted file mode 100644
index f91d858..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java	
+++ /dev/null
@@ -1,66 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual banknotes. The value of a
- * banknote is assumed to always be a positive integer multiple of the base
- * currency.
- */
-public class Banknote {
-	private int value;
-	private Currency currency;
-
-	/**
-	 * Constructs a banknote.
-	 * @param currency
-	 *            The currency represented by this banknote.
-	 * @param value
-	 *            The value of the banknote, in multiples of the unit of currency.
-	 * 
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If currency is null.
-	 */
-	public Banknote(Currency currency, int value) {
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the banknote. Should always be &gt;0.
-	 */
-	public int getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this banknote. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
-	 *             dollars, so a Canadian $10 bill would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return Integer.toString(value) + " " + currency;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
deleted file mode 100644
index b8e1f7c..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java	
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents a barcode value (not the graphic barcode itself). Real-world
- * barcodes are a sequence of digits, so that is what is modelled here.
- */
-public class Barcode {
-	private Numeral[] digits;
-
-	/**
-	 * Constructs a barcode from an array of numerals.
-	 * 
-	 * @param code
-	 *            An array of numerals.
-	 * @throws SimulationException
-	 *             If any character in the input is not a digit between 0 and 9,
-	 *             inclusive.
-	 * @throws SimulationException
-	 *             If the code is null
-	 * @throws SimulationException
-	 *             If the code's length is &lt;1 or &gt;48.
-	 */
-	public Barcode(Numeral[] code) {
-		if(code == null)
-			throw new SimulationException(new NullPointerException("code is null"));
-
-		digits = new Numeral[code.length];
-
-		if(code.length < 1)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain less than one digit."));
-
-		if(code.length > 48)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
-
-		for(int i = 0; i < code.length; i++) {
-			if(code[i] == null)
-				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
-
-			digits[i] = code[i];
-		}
-	}
-
-	/**
-	 * Gets the count of digits in this code.
-	 * 
-	 * @return The count of digits.
-	 */
-	public int digitCount() {
-		return digits.length;
-	}
-
-	/**
-	 * Gets the digit at the indicated index within the code.
-	 * 
-	 * @param index
-	 *            The index of the digit, &ge;0 and &lt;count.
-	 * @return The digit at the indicated index.
-	 * @throws SimulationException
-	 *             If the index is outside the legal range.
-	 */
-	public Numeral getDigitAt(int index) {
-		try {
-			return digits[index];
-		}
-		catch(IndexOutOfBoundsException e) {
-			throw new SimulationException(e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		char[] characters = new char[digits.length];
-
-		for(int i = 0; i < digits.length; i++)
-			characters[i] = Character.forDigit(digits[i].getValue(), 10);
-
-		return new String(characters);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(object instanceof Barcode) {
-			Barcode other = (Barcode)object;
-
-			if(other.digits.length != digits.length)
-				return false;
-
-			for(int i = 0; i < digits.length; i++)
-				if(!digits[i].equals(other.digits[i]))
-					return false;
-
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return Arrays.hashCode(digits);
-	}
-}
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
deleted file mode 100644
index fab9792..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Represents items for sale, each with a particular barcode and weight.
- */
-public class BarcodedItem extends Item {
-	private Barcode barcode;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param kind
-	 *            The kind of product that this item is.
-	 * @param weightInGrams
-	 *            The real weight of the item.
-	 * @throws SimulationException
-	 *             If the barcode is null.
-	 * @throws SimulationException
-	 *             If the weight is &le;0.
-	 */
-	public BarcodedItem(Barcode barcode, double weightInGrams) {
-		super(weightInGrams);
-
-		if(barcode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		this.barcode = barcode;
-	}
-
-	/**
-	 * Gets the barcode of this item.
-	 * 
-	 * @return The barcode.
-	 */
-	public Barcode getBarcode() {
-		return barcode;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
deleted file mode 100644
index 3b6416e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from a blocked card.
- */
-public class BlockedCardException extends IOException {
-	private static final long serialVersionUID = 8824192400137175094L;
-
-	/**
-	 * Create an exception.
-	 */
-	public BlockedCardException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
deleted file mode 100644
index 58da94a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java	
+++ /dev/null
@@ -1,289 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-import java.util.Random;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
- */
-public final class Card {
-	private final String type;
-	private final String number;
-	private final String cardholder;
-	private final String cvv;
-	private final String pin;
-	public final boolean isTapEnabled;
-	public final boolean hasChip;
-	private int failedTrials = 0;
-	private boolean isBlocked;
-
-	/**
-	 * Create a card instance.
-	 * 
-	 * @param type
-	 *            The type of the card.
-	 * @param number
-	 *            The number of the card. This has to be a string of digits.
-	 * @param cardholder
-	 *            The name of the cardholder.
-	 * @param cvv
-	 *            The card verification value (CVV), a 3- or 4-digit value often on
-	 *            the back of the card. This can be null.
-	 * @param pin
-	 *            The personal identification number (PIN) for access to the card.
-	 *            This can be null if the card has no chip.
-	 * @param isTapEnabled
-	 *            Whether this card is capable of being tapped.
-	 * @param hasChip
-	 *            Whether this card has a chip.
-	 * @throws SimulationException
-	 *             If type, number, or cardholder is null.
-	 * @throws SimulationException
-	 *             If hasChip is true but pin is null.
-	 */
-	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
-		boolean hasChip) {
-		if(type == null)
-			throw new SimulationException(new NullPointerException("type is null"));
-
-		if(number == null)
-			throw new SimulationException(new NullPointerException("number is null"));
-
-		if(cardholder == null)
-			throw new SimulationException(new NullPointerException("cardholder is null"));
-
-		if(hasChip && pin == null)
-			throw new SimulationException(new NullPointerException("has chip but pin is null"));
-
-		this.type = type;
-		this.number = number;
-		this.cardholder = cardholder;
-		this.cvv = cvv;
-		this.pin = pin;
-		this.isTapEnabled = isTapEnabled;
-		this.hasChip = hasChip;
-	}
-
-	private static final Random random = new Random(0);
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
-	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
-	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
-	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
-
-	/**
-	 * Simulates the action of swiping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardSwipeData swipe() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
-			throw new MagneticStripeFailureException();
-
-		return new CardSwipeData();
-	}
-
-	/**
-	 * Simulates the action of tapping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardTapData tap() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(isTapEnabled) {
-			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
-				throw new TapFailureException();
-
-			return new CardTapData();
-		}
-
-		return null;
-	}
-
-	/**
-	 * Simulates the action of inserting the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardInsertData insert(String pin) throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(hasChip) {
-			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
-				throw new ChipFailureException();
-
-			return new CardInsertData(pin);
-		}
-
-		return null;
-	}
-
-	private String randomize(String original, double probability) {
-		if(random.nextDouble() <= probability) {
-			int length = original.length();
-			int index = random.nextInt(length);
-			String first;
-
-			if(index == 0)
-				first = "";
-			else
-				first = original.substring(0, index);
-
-			char second = original.charAt(index);
-			second++;
-
-			String third;
-
-			if(index == length - 1)
-				third = "";
-			else
-				third = original.substring(index + 1, length);
-
-			return first + second + third;
-		}
-
-		return original;
-	}
-
-	/**
-	 * The abstract base type of card data.
-	 */
-	public interface CardData {
-		/**
-		 * Gets the type of the card.
-		 * 
-		 * @return The type of the card.
-		 */
-		public String getType();
-
-		/**
-		 * Gets the number of the card.
-		 * 
-		 * @return The number of the card.
-		 */
-		public String getNumber();
-
-		/**
-		 * Gets the cardholder's name.
-		 * 
-		 * @return The cardholder's name.
-		 */
-		public String getCardholder();
-
-		/**
-		 * Gets the card verification value (CVV) of the card.
-		 * 
-		 * @return The CVV of the card.
-		 * @throws UnsupportedOperationException
-		 *             If this operation is unsupported by this object.
-		 */
-		public String getCVV();
-	}
-
-	/**
-	 * The data from swiping a card.
-	 */
-	public class CardSwipeData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			throw new UnsupportedOperationException();
-		}
-	}
-
-	/**
-	 * The data from tapping a card.
-	 */
-	public final class CardTapData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-	}
-
-	/**
-	 * The data from inserting a card.
-	 */
-	public final class CardInsertData implements CardData {
-		CardInsertData(String pin) throws InvalidPINException {
-			if(!testPIN(pin))
-				throw new InvalidPINException();
-		}
-
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		private boolean testPIN(String pinToTest) {
-			if(pinToTest == pin) {
-				failedTrials = 0;
-				return true;
-			}
-
-			if(++failedTrials >= 3)
-				isBlocked = true;
-
-			return false;
-		}
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
deleted file mode 100644
index 00c7c18..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of the chip.
- */
-public class ChipFailureException extends IOException {
-	private static final long serialVersionUID = 3518203688837080092L;
-
-	/**
-	 * Create an exception.
-	 */
-	public ChipFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
deleted file mode 100644
index ede38a9..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java	
+++ /dev/null
@@ -1,98 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual coins.
- */
-public class Coin {
-	private BigDecimal value;
-	private Currency currency;
-
-	/**
-	 * Rather than specifying a currency for every coin, a default currency can be
-	 * specified which will be used when the currency is not specified.
-	 */
-	public static Currency DEFAULT_CURRENCY;
-
-	/**
-	 * Constructs a coin, using the default currency.
-	 * 
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 */
-	public Coin(BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(DEFAULT_CURRENCY == null)
-			throw new SimulationException(new NullPointerException("Default currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = DEFAULT_CURRENCY;
-	}
-		
-	/**
-	 * Constructs a coin.
-	 * 
-	 * @param currency
-	 *            The currency represented by this coin.
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 */
-	public Coin(Currency currency, BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the coin. Should always be greater than 0.
-	 */
-	public BigDecimal getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this coin. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
-	 *             dollars, so a Canadian dime would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return value.toString() + " " + currency;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
deleted file mode 100644
index 22e6f63..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.lsmr.selfcheckout;
-
-/**
- * Signals that an illegal character has been used where a digit (0-9) was
- * expected.
- */
-public class IllegalDigitException extends IllegalArgumentException {
-	private static final long serialVersionUID = 3352152121776245096L;
-
-	/**
-	 * Constructs an exception with an error message.
-	 * 
-	 * @param message
-	 *            The error message to display.
-	 */
-	public IllegalDigitException(String message) {
-		super(message);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
deleted file mode 100644
index 7134225..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from entry of an invalid PIN.
- */
-public class InvalidPINException extends IOException {
-	private static final long serialVersionUID = 5461848339919309513L;
-
-	/**
-	 * Create an exception.
-	 */
-	public InvalidPINException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
deleted file mode 100644
index 24e2842..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java	
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Abstract base class of items for sale, each with a particular weight.
- */
-public abstract class Item {
-	private double weightInGrams;
-
-	/**
-	 * Constructs an item with the indicated weight.
-	 * 
-	 * @param weightInGrams
-	 *            The weight of the item.
-	 * @throws SimulationException
-	 *             If the weight is &le;0.
-	 */
-	protected Item(double weightInGrams) {
-		if(weightInGrams <= 0.0)
-			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
-
-		this.weightInGrams = weightInGrams;
-	}
-
-	/**
-	 * The weight of the item, in grams.
-	 * 
-	 * @return The weight in grams.
-	 */
-	public double getWeight() {
-		return weightInGrams;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
deleted file mode 100644
index fc5396e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of the magnetic stripe.
- */
-public class MagneticStripeFailureException extends IOException {
-	private static final long serialVersionUID = -4703845851722394414L;
-
-	/**
-	 * Create an exception.
-	 */
-	public MagneticStripeFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
deleted file mode 100644
index c53e6f7..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java	
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.lsmr.selfcheckout;
-
-/**
- * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
- * in English.
- */
-public enum Numeral {
-	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
-	eight((byte)8), nine((byte)9), zero((byte)0);
-
-	private byte value;
-
-	private Numeral(byte value) {
-		this.value = value;
-	}
-
-	/**
-	 * Obtains the numeric value of the numeral.
-	 * 
-	 * @return The numeric value of the numeral.
-	 */
-	public byte getValue() {
-		return value;
-	}
-
-	/**
-	 * Converts a number between 0 and 9 into the corresponding numeral.
-	 * 
-	 * @param number
-	 *            The number to convert. It must be between 0 and 9, inclusive.
-	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
-	 */
-	public static Numeral valueOf(byte number) {
-		switch(number) {
-		case 0:
-			return zero;
-		case 1:
-			return one;
-		case 2:
-			return two;
-		case 3:
-			return three;
-		case 4:
-			return four;
-		case 5:
-			return five;
-		case 6:
-			return six;
-		case 7:
-			return seven;
-		case 8:
-			return eight;
-		case 9:
-			return nine;
-		default:
-			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
-		}
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
deleted file mode 100644
index e0985d0..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Represents items for sale, each with a particular barcode and weight.
- */
-public class PLUCodedItem extends Item {
-	private PriceLookupCode pluCode;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param kind
-	 *            The kind of product that this item is.
-	 * @param weightInGrams
-	 *            The actual weight of the item.
-	 */
-	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
-		super(weightInGrams);
-		
-		if(pluCode == null)
-			throw new SimulationException(new NullPointerException("pluCode is null"));
-		
-		this.pluCode = pluCode;
-	}
-
-	/**
-	 * Gets the PLU code of this item.
-	 * 
-	 * @return The PLU code.
-	 */
-	public PriceLookupCode getPLUCode() {
-		return pluCode;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
deleted file mode 100644
index c860edc..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents a PLU value, a sequence of digits that, in principle, could lie
- * anywhere in the range 0000-99999. Specific subranges are reserved for specific
- * purposes in the real world, but we will not worry about that here.
- */
-public class PriceLookupCode {
-	private Numeral[] numerals;
-
-	/**
-	 * Constructs a PLU code from a string of numerals. There must be at least 4
-	 * digits and at most 5.
-	 * 
-	 * @param code
-	 *            A string of digits.
-	 * @throws SimulationException
-	 *             If any character in the input is not a digit between 0 and 9,
-	 *             inclusive.
-	 * @throws SimulationException
-	 *             If the code contains less than 4 digits or more than 5 digits.
-	 * @throws NullPointerException
-	 *             If code is null.
-	 */
-	public PriceLookupCode(String code) {
-		if(code == null)
-			throw new SimulationException(new NullPointerException("code is null"));
-
-		char[] charArray = code.toCharArray();
-		numerals = new Numeral[charArray.length];
-
-		if(code.length() > 5)
-			throw new SimulationException(
-				new IllegalArgumentException("The code cannot contain more than five digits."));
-
-		if(code.length() < 4)
-			throw new SimulationException(
-				new IllegalArgumentException("The code cannot contain less than four digits."));
-
-		for(int i = 0; i < charArray.length; i++) {
-			try {
-				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
-			}
-			catch(IllegalDigitException e) {
-				throw new SimulationException(e);
-			}
-		}
-	}
-
-	/**
-	 * Gets the count of numerals in this code.
-	 * 
-	 * @return The count of numerals.
-	 */
-	public int numeralCount() {
-		return numerals.length;
-	}
-
-	/**
-	 * Gets the numeral at the indicated index within the code.
-	 * 
-	 * @param index
-	 *            The index of the numeral, &ge;0 and &lt;count.
-	 * @return The numeral at the indicated index.
-	 * @throws SimulationException
-	 *             If the index is outside the legal range.
-	 */
-	public Numeral getNumeralAt(int i) {
-		try {
-			return numerals[i];
-		}
-		catch(IndexOutOfBoundsException e) {
-			throw new SimulationException(e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		char[] characters = new char[numerals.length];
-
-		for(int i = 0; i < numerals.length; i++)
-			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
-
-		return new String(characters);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(object instanceof PriceLookupCode) {
-			PriceLookupCode other = (PriceLookupCode)object;
-
-			if(other.numerals.length != numerals.length)
-				return false;
-
-			for(int i = 0; i < numerals.length; i++)
-				if(!numerals[i].equals(other.numerals[i]))
-					return false;
-
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return Arrays.hashCode(numerals);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
deleted file mode 100644
index 66ea14e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of taps.
- */
-public class TapFailureException extends IOException {
-	private static final long serialVersionUID = -8812895797883270979L;
-
-	/**
-	 * Create an exception.
-	 */
-	public TapFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
deleted file mode 100644
index 20cb12a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
+++ /dev/null
@@ -1,193 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-/**
- * The abstract base class for all devices involved in the simulator.
- * <p>
- * This class utilizes the Observer design pattern. Subclasses inherit the
- * attach method, but each must define its own notifyXXX methods.
- * </p>
- * <p>
- * Each device must be coupled to an appropriate observer interface, which
- * extends AbstractDeviceObserver; the type parameter T represents this
- * observer.
- * <p>
- * <p>
- * Any individual device can be disabled, which means it will not permit
- * physical movements to be caused by the software. Any method that could cause
- * a physical movement will declare that it throws DisabledException.
- * </p>
- * 
- * @param <T>
- *            The type of observers used for this device. For a device whose
- *            class is X, its corresponding observer interface would typically
- *            be XObserver.
- */
-public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
-	/**
-	 * Used to represent the operation phase of this device.
-	 */
-	protected enum Phase {
-		/**
-		 * The device is being configured.
-		 */
-		CONFIGURATION,
-		/**
-		 * The device is in normal operation.
-		 */
-		NORMAL,
-		/**
-		 * The device has undergone a fatal error requiring physical repair and reset.
-		 */
-		ERROR
-	}
-
-	/**
-	 * The current operation phase of this device.
-	 */
-	protected Phase phase = Phase.CONFIGURATION;
-
-	/**
-	 * Many devices require configuration before their use. Before configuration is
-	 * complete, the device should not operate. Once configuration is complete, any
-	 * further configuration attempts should cause exceptions.
-	 */
-	public void endConfigurationPhase() {
-		phase = Phase.NORMAL;
-	}
-
-	/**
-	 * For testing purposes only. Forces this device into an erroneous state.
-	 */
-	public void forceErrorPhase() {
-		phase = Phase.ERROR;
-	}
-
-	/**
-	 * A list of the registered observers on this device.
-	 */
-	protected ArrayList<T> observers = new ArrayList<>();
-
-	/**
-	 * Locates the indicated observer and removes it such that it will no longer be
-	 * informed of events from this device. If the observer is not currently
-	 * registered with this device, calls to this method will return false, but
-	 * otherwise have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to remove.
-	 * @return true if the observer was found and removed, false otherwise.
-	 */
-	public final boolean detach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return observers.remove(observer);
-	}
-
-	/**
-	 * All observers registered with this device are removed. If there are none,
-	 * calls to this method have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 */
-	public final void detachAll() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		observers.clear();
-	}
-
-	/**
-	 * Registers the indicated observer to receive event notifications from this
-	 * device.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to be added.
-	 */
-	public final void attach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(observer == null)
-			throw new SimulationException(new IllegalArgumentException(
-				"This method may not receive null, as it has no analogue in the real world."));
-
-		observers.add(observer);
-	}
-
-	private boolean disabled = false;
-
-	/**
-	 * Disables this device from receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void disable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = true;
-		notifyDisabled();
-	}
-
-	private void notifyDisabled() {
-		for(T observer : observers)
-			observer.disabled(this);
-	}
-
-	/**
-	 * Enables this device for receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void enable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = false;
-		notifyEnabled();
-	}
-
-	private void notifyEnabled() {
-		for(T observer : observers)
-			observer.enabled(this);
-	}
-
-	/**
-	 * Returns whether this device is currently disabled from receiving input and
-	 * producing output.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return true if the device is disabled; false if the device is enabled.
-	 */
-	public final boolean isDisabled() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return disabled;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
deleted file mode 100644
index d3890b1..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that accept things.
- * 
- * @param <T>
- *            The type of the things to accept.
- */
-public interface Acceptor<T> {
-	/**
-	 * Instructs the device to take the thing as input.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to be taken as input.
-	 * @throws OverloadException
-	 *             If the device does not have enough space for the thing.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 */
-	public void accept(T thing) throws OverloadException, DisabledException;
-
-	/**
-	 * Checks whether the device has enough space to expect one more thing. If this
-	 * method returns true, an immediate call to accept should not throw
-	 * CapacityExceededException, unless an asynchronous addition has occurred in
-	 * the meantime.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @return true If there is space; otherwise, false.
-	 */
-	public boolean hasSpace();
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
deleted file mode 100644
index df4e37e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
+++ /dev/null
@@ -1,213 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
-
-/**
- * Represents a device that stores banknotes (as known as bills, paper money,
- * etc.) of a particular denomination to dispense them as change.
- * <p>
- * Banknote dispensers can receive banknotes from other sources. To simplify the
- * simulation, no check is performed on the value of each banknote.
- * </p>
- */
-public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
-	implements FromStorageEmitter<Banknote> {
-	private int maxCapacity;
-	private Queue<Banknote> queue = new LinkedList<Banknote>();
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that can be stored in the
-	 *            dispenser. Must be positive.
-	 * @throws SimulationException
-	 *             If capacity is not positive.
-	 */
-	public BanknoteDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of banknotes in the dispenser.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return The number of banknotes currently in the dispenser.
-	 */
-	public int size() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
-	 * banknotes in the dispenser are not removed.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each may not be null.
-	 * @throws OverloadException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the dispenser.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + banknotes.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(new NullPointerException("A banknote is null."));
-			else
-				queue.add(banknote);
-
-		notifyBanknotesLoaded(banknotes);
-	}
-
-	/**
-	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
-	 * event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
-
-		return result;
-	}
-
-	/**
-	 * Connects an output channel to this banknote dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this banknote dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return maxCapacity;
-	}
-
-	/**
-	 * Emits a single banknote from this banknote dispenser. If successful, a
-	 * "banknoteRemoved" event is announced to its observers. If a successful
-	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
-	 * event is instead announced to its observers.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             if the output channel is unable to accept another banknote.
-	 * @throws EmptyException
-	 *             if no banknotes are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             if the dispenser is currently disabled.
-	 */
-	public void emit() throws EmptyException, DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Banknote banknote = queue.remove();
-
-		if(sink.hasSpace())
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		else
-			throw new OverloadException("The sink is full.");
-
-		if(queue.isEmpty())
-			notifyBanknotesEmpty();
-		else
-			notifyBanknoteRemoved(banknote);
-	}
-
-	private void notifyBanknoteRemoved(Banknote banknote) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknoteRemoved(this, banknote);
-	}
-
-	private void notifyBanknotesEmpty() {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesEmpty(this);
-	}
-
-	private void notifyBanknotesLoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesLoaded(this, banknotes);
-	}
-
-	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesUnloaded(this, banknotes);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
deleted file mode 100644
index e8f30e4..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
+++ /dev/null
@@ -1,191 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
-
-/**
- * Represents a simple banknote slot device that can either accept a banknote or
- * eject the most recently inserted banknote, leaving it dangling until the
- * customer removes it, via {@link #removeDanglingBanknote()}.
- */
-public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
-	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
-	private BidirectionalChannel<Banknote> sink;
-	private boolean invert;
-
-	/**
-	 * Creates a banknote slot.
-	 * 
-	 * @param invert
-	 *            If the slot is to be inverted.
-	 */
-	public BanknoteSlot(boolean invert) {
-		this.invert = invert;
-	}
-
-	/**
-	 * Connects an output channel to the banknote slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where banknotes are passed into the machine.
-	 */
-	public void connect(BidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the banknote slot that the indicated banknote is being inserted. If the
-	 * sink can accept the banknote, the banknote is passed to the sink and a
-	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
-	 * "banknoteEjected" event is announced to the slot's observers, meaning that
-	 * the banknote is returned to the user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote slot is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 * @throws OverloadException
-	 *             If a banknote is dangling from the slot.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(danglingEjectedBanknote != null)
-			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
-
-		notifyBanknoteInserted();
-
-		if(!invert && sink.hasSpace()) {
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else {
-			danglingEjectedBanknote = banknote;
-			notifyBanknoteEjected();
-		}
-	}
-
-	private Banknote danglingEjectedBanknote = null;
-
-	/**
-	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
-	 * it.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be ejected.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 * @throws SimulationException
-	 *             If a banknote is already dangling from the slot.
-	 */
-	public void emit(Banknote banknote) throws DisabledException, SimulationException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(danglingEjectedBanknote != null)
-			throw new SimulationException(
-				"A banknote is already dangling from the slot. Remove that before ejecting another.");
-
-		danglingEjectedBanknote = banknote;
-
-		notifyBanknoteEjected();
-	}
-
-	/**
-	 * Simulates the user removing a banknote that is dangling from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The formerly dangling banknote.
-	 */
-	public Banknote removeDanglingBanknote() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(danglingEjectedBanknote == null)
-			throw new SimulationException("A banknote that does not exist cannot be removed.");
-
-		Banknote b = danglingEjectedBanknote;
-		danglingEjectedBanknote = null;
-		notifyBanknoteRemoved();
-
-		return b;
-	}
-
-	/**
-	 * Tests whether a banknote can be accepted by or ejected from this slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
-	 *             false.
-	 */
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return danglingEjectedBanknote == null;
-	}
-
-	private void notifyBanknoteInserted() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteInserted(this);
-	}
-
-	private void notifyBanknoteEjected() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteEjected(this);
-	}
-
-	private void notifyBanknoteRemoved() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteRemoved(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
deleted file mode 100644
index d773a2b..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
+++ /dev/null
@@ -1,199 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
-
-/**
- * Represents devices that store banknotes. They only receive banknotes, not
- * dispense them. To access the banknotes inside, a human operator needs to
- * physically remove the banknotes, simulated with the {@link #unload()} method.
- * A {@link #load(Banknote...)} method is provided for symmetry.
- */
-public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
-	private Banknote[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a banknote storage unit that can hold the indicated number of
-	 * banknotes.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public BanknoteStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Banknote[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of banknotes that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of banknotes contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getBanknoteCount() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the storage unit directly.
-	 * Existing banknotes in the dispenser are not removed. Causes a
-	 * "banknotesLoaded" event to be announced. Disabling has no effect on
-	 * loading/unloading.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the unit.
-	 * @throws SimulationException
-	 *             If the banknotes argument is null.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 * @throws OverloadException
-	 *             If too many banknotes are stuffed in the unit.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(banknotes == null)
-			throw new SimulationException(
-				new NullPointerException("banknotes is null which has no analogue in the real world"));
-
-		if(banknotes.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(
-					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
-
-		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
-		nextIndex += banknotes.length;
-
-		notifyBanknotesLoaded();
-	}
-
-	/**
-	 * Unloads banknotes from the storage unit directly. Causes a
-	 * "banknotesUnloaded" event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> banknotes = Arrays.asList(storage);
-
-		storage = new Banknote[storage.length];
-		nextIndex = 0;
-		notifyBanknotesUnloaded();
-
-		return banknotes;
-	}
-
-	/**
-	 * Causes the indicated banknote to be added to the storage unit. If successful,
-	 * a "banknoteAdded" event is announced to its observers. If a successful
-	 * banknote addition causes the unit to become full, a "banknotesFull" event is
-	 * instead announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to add.
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If banknote is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(
-				new NullPointerException("banknote is null, which has no analogue in the real world."));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = banknote;
-
-			if(nextIndex == storage.length)
-				notifyBanknotesFull();
-			else
-				notifyBanknoteAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyBanknotesLoaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesLoaded(this);
-	}
-
-	private void notifyBanknotesUnloaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesUnloaded(this);
-	}
-
-	private void notifyBanknotesFull() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesFull(this);
-	}
-
-	private void notifyBanknoteAdded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknoteAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
deleted file mode 100644
index fc32c76..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
-
-/**
- * Represents a device for optically and/or magnetically validating banknotes.
- * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
- * ejected.
- */
-public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
-	implements Acceptor<Banknote>, Emitter<Banknote> {
-	private final Currency currency;
-	private final int[] denominations;
-	private BidirectionalChannel<Banknote> source;
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote validator that recognizes banknotes of the specified
-	 * denominations (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid banknote denominations (like $5, $10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public BanknoteValidator(Currency currency, int[] denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.length < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Arrays.sort(denominations);
-
-		HashSet<Integer> set = new HashSet<>();
-
-		for(int denomination : denominations) {
-			if(denomination <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(set.contains(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			set.add(denomination);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the banknote validator. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param source
-	 *            The channel from which banknotes normally arrive for validation,
-	 *            and to which invalid banknotes will be ejected.
-	 * @param sink
-	 *            The channel to which all valid banknotes are routed.
-	 */
-	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.source = source;
-		this.sink = sink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Banknote banknote) {
-		if(currency.equals(banknote.getCurrency()))
-			for(int denomination : denominations)
-				if(denomination == banknote.getValue())
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the banknote validator that the indicated banknote is being inserted.
-	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
-	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
-	 * observers.
-	 * <p>
-	 * If there is space in the machine to store a valid banknote, it is passed to
-	 * the sink channel.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the banknote is invalid,
-	 * the banknote is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 */
-	@Override
-	public void accept(Banknote banknote) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(isValid(banknote)) {
-			notifyValidBanknoteDetected(banknote);
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					source.eject(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidBanknoteDetected();
-
-			try {
-				source.eject(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException("Unable to route banknote: sink is full");
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return true;
-	}
-
-	private void notifyValidBanknoteDetected(Banknote banknote) {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
-	}
-
-	private void notifyInvalidBanknoteDetected() {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.invalidBanknoteDetected(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
deleted file mode 100644
index 7e926a5..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Random;
-
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-
-/**
- * A complex device hidden behind a simple simulation. They can scan and that is
- * about all.
- */
-public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
-	/**
-	 * Create a barcode scanner.
-	 */
-	public BarcodeScanner() {}
-
-	private Random random = new Random();
-	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
-
-	/**
-	 * Simulates the customer's action of scanning an item. The result of the scan
-	 * is only announced to any registered observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to scan. Of course, it will only work if the item has a
-	 *            barcode, and maybe not even then.
-	 * @throws SimulationException
-	 *             If item is null.
-	 */
-	public void scan(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			return; // silently ignore it
-
-		if(item == null)
-			throw new SimulationException(
-				new NullPointerException("item is null, which has no analogue in the real world."));
-
-		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
-			notifyBarcodeScanned((BarcodedItem)item);
-
-		// otherwise, silently ignore it
-	}
-
-	private void notifyBarcodeScanned(BarcodedItem item) {
-		for(BarcodeScannerObserver l : observers)
-			l.barcodeScanned(this, item.getBarcode());
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
deleted file mode 100644
index 433dc07..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-
-/**
- * Represents a simple device (like, say, a tube or just a physical connection)
- * that moves things between other devices. This channel is bidirectional.
- * 
- * @param <T>
- *            The type of the things to move.
- */
-public final class BidirectionalChannel<T> {
-	private FlowThroughEmitter<T> source;
-	private Acceptor<T> sink;
-
-	/**
-	 * Constructs a new channel whose input is connected to the indicated source and
-	 * whose output is connected to the indicated sink.
-	 * 
-	 * @param source
-	 *            The device at the output end of the channel.
-	 * @param sink
-	 *            The device at the output end of the channel.
-	 */
-	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
-		this.source = source;
-		this.sink = sink;
-	}
-
-	/**
-	 * Moves the indicated thing to the source. This method should be called by
-	 * the sink device, and not by an external application.
-	 * 
-	 * @param thing
-	 *            The thing to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void eject(T thing) throws OverloadException, DisabledException {
-		source.emit(thing);
-	}
-
-	/**
-	 * Moves the indicated banknote to the sink. This method should be called by the
-	 * source device, and not by an external application.
-	 * 
-	 * @param banknote
-	 *            The banknote to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void deliver(T banknote) throws OverloadException, DisabledException {
-		sink.accept(banknote);
-	}
-
-	/**
-	 * Returns whether the sink has space for at least one more banknote.
-	 * 
-	 * @return true if the sink can accept a banknote; false otherwise.
-	 */
-	public boolean hasSpace() {
-		return sink.hasSpace();
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
deleted file mode 100644
index 6f54d0d..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
+++ /dev/null
@@ -1,185 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.awt.image.BufferedImage;
-import java.io.IOException;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.Card;
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.ChipFailureException;
-import org.lsmr.selfcheckout.MagneticStripeFailureException;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
-
-/**
- * Represents the card reader, capable of tap, chip insert, and swipe. Either
- * the reader or the card may fail, or the data read in can be corrupted, with
- * varying probabilities.
- */
-public class CardReader extends AbstractDevice<CardReaderObserver> {
-	private boolean cardIsInserted = false;
-
-	/**
-	 * Create a card reader.
-	 */
-	public CardReader() {}
-
-	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
-	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
-
-	/**
-	 * Tap the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to tap.
-	 * @return The card's (possibly corrupted) data, or null if the card is not tap
-	 *             enabled.
-	 * @throws IOException
-	 *             If the tap failed (lack of failure does not mean that the data is
-	 *             not corrupted).
-	 */
-	public CardData tap(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(card.isTapEnabled) {
-			notifyCardTapped();
-
-			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
-				CardData data = card.tap();
-
-				notifyCardDataRead(data);
-
-				return data;
-			}
-			else
-				throw new ChipFailureException();
-		}
-
-		// else ignore
-		return null;
-	}
-
-	/**
-	 * Swipe the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to swipe.
-	 * @return The card data.
-	 * @throws IOException
-	 *             If the swipe failed.
-	 */
-	public CardData swipe(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		notifyCardSwiped();
-
-		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
-			CardData data = card.swipe();
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new MagneticStripeFailureException();
-	}
-
-	/**
-	 * Insert the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to insert.
-	 * @param pin
-	 *            The customer's PIN.
-	 * @return The card data.
-	 * @throws SimulationException
-	 *             If there is already a card in the slot.
-	 * @throws IOException
-	 *             The insertion failed.
-	 */
-	public CardData insert(Card card, String pin) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(cardIsInserted)
-			throw new IllegalStateException("There is already a card in the slot");
-
-		cardIsInserted = true;
-
-		notifyCardInserted();
-
-		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
-			CardData data = card.insert(pin);
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new ChipFailureException();
-	}
-
-	/**
-	 * Remove the card from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public void remove() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		cardIsInserted = false;
-		notifyCardRemoved();
-	}
-
-	private void notifyCardTapped() {
-		for(CardReaderObserver l : observers)
-			l.cardTapped(this);
-	}
-
-	private void notifyCardInserted() {
-		for(CardReaderObserver l : observers)
-			l.cardInserted(this);
-	}
-
-	private void notifyCardSwiped() {
-		for(CardReaderObserver l : observers)
-			l.cardSwiped(this);
-	}
-
-	private void notifyCardDataRead(CardData data) {
-		for(CardReaderObserver l : observers)
-			l.cardDataRead(this, data);
-	}
-
-	private void notifyCardRemoved() {
-		for(CardReaderObserver l : observers)
-			l.cardRemoved(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
deleted file mode 100644
index 838766e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
+++ /dev/null
@@ -1,262 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
-
-/**
- * Represents a device that stores coins of a particular denomination to
- * dispense them as change.
- * <p>
- * Coin dispensers can receive coins from other sources. To simplify the
- * simulation, no check is performed on the value of each coin, meaning it is an
- * external responsibility to ensure the correct routing of coins.
- * </p>
- */
-public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
-	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
-	private int maxCapacity;
-	private Queue<Coin> queue = new LinkedList<Coin>();
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that can be stored in the dispenser.
-	 *            Must be positive.
-	 * @throws SimulationException
-	 *             if capacity is not positive.
-	 */
-	public CoinDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of coins in the dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The number of coins currently in the dispenser.
-	 */
-	public int size() {
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the dispenser directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws OverloadException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             dispenser.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + coins.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("A coin is null"));
-			else
-				queue.add(coin);
-
-		notifyLoad(coins);
-	}
-
-	private void notifyLoad(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsLoaded(this, coins);
-	}
-
-	/**
-	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
-	 * be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyUnload(result.toArray(new Coin[result.size()]));
-
-		return result;
-	}
-
-	private void notifyUnload(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsUnloaded(this, coins);
-	}
-
-	/**
-	 * Connects an output channel to this coin dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is only permissible during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this coin dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		return maxCapacity;
-	}
-
-	/**
-	 * Causes the indicated coin to be added into the dispenser. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition causes the dispenser to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the coin dispenser is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the coin dispenser is already full.
-	 */
-	@Override
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(queue.size() >= maxCapacity)
-			throw new OverloadException();
-
-		queue.add(coin);
-		notifyCoinAdded(coin);
-
-		if(queue.size() >= maxCapacity)
-			notifyCoinsFull();
-	}
-
-	/**
-	 * Releases a single coin from this coin dispenser. If successful, a
-	 * "coinRemoved" event is announced to its observers. If a successful coin
-	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             If the output channel is unable to accept another coin.
-	 * @throws EmptyException
-	 *             If no coins are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             If the dispenser is currently disabled.
-	 */
-	public void emit() throws OverloadException, EmptyException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Coin coin = queue.remove();
-
-		notifyCoinRemoved(coin);
-		sink.deliver(coin);
-
-		if(queue.isEmpty())
-			notifyCoinsEmpty();
-	}
-
-	/**
-	 * Returns whether this coin dispenser has enough space to accept at least one
-	 * more coin. Announces no events.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size() < maxCapacity;
-	}
-
-	private void notifyCoinAdded(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinAdded(this, coin);
-	}
-
-	private void notifyCoinRemoved(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinRemoved(this, coin);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsFull(this);
-	}
-
-	private void notifyCoinsEmpty() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsEmpty(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
deleted file mode 100644
index 9cc3516..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
+++ /dev/null
@@ -1,97 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
-
-/**
- * Represents a simple coin slot device that has one output channel. The slot is
- * stupid: it has no functionality other than being enabled/disabled, and cannot
- * determine the value and currency of the coin.
- */
-public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin slot.
-	 */
-	public CoinSlot() {}
-
-	/**
-	 * Connects channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where coins will always be passed.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
-	 * enabled, this causes a "coinInserted" event to be announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             If the coin slot is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws NullPointerException
-	 *             If the coin is null.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		notifyCoinInserted();
-
-		if(sink.hasSpace()) {
-			try {
-				sink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else
-			throw new SimulationException("Unable to route coin: Output channel is full");
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return sink.hasSpace();
-	}
-
-	private void notifyCoinInserted() {
-		for(CoinSlotObserver observer : observers)
-			observer.coinInserted(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
deleted file mode 100644
index 97d5929..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
+++ /dev/null
@@ -1,186 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
-
-/**
- * Represents devices that store coins. They only receive coins, not dispense
- * them. To access the coins inside, a human operator needs to physically remove
- * the coins, simulated with the {@link #unload()} method. A
- * {@link #load(Coin...)} method is provided for symmetry.
- */
-public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
-	private Coin[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin storage unit that can hold the indicated number of coins.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public CoinStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Coin[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of coins that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of coins contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getCoinCount() {
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the storage unit directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced. Disabling has no effect on loading/unloading.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             unit.
-	 * @throws SimulationException
-	 *             If coins is null.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 * @throws OverloadException
-	 *             If too many coins are loaded.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(coins == null)
-			throw new SimulationException(
-				new NullPointerException("coins is null, which has no analogue in the real world."));
-
-		if(coins.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("No coin may be null"));
-
-		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
-		nextIndex += coins.length;
-
-		notifyCoinsLoaded();
-	}
-
-	/**
-	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
-	 * to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> coins = Arrays.asList(storage);
-
-		storage = new Coin[storage.length];
-		nextIndex = 0;
-		notifyCoinsUnloaded();
-
-		return coins;
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the storage unit. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition instead causes the unit to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Coin coin) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = coin;
-
-			if(nextIndex == storage.length)
-				notifyCoinsFull();
-			else
-				notifyCoinAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyCoinsLoaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsLoaded(this);
-	}
-
-	private void notifyCoinsUnloaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsUnloaded(this);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsFull(this);
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
deleted file mode 100644
index 3ee4da7..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
+++ /dev/null
@@ -1,102 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
-
-/**
- * Simulates the tray where dispensed coins go for the user to collect them.
- */
-public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
-	private Coin[] coins;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin tray.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that this tray can hold without
-	 *            overflowing.
-	 * @throws SimulationException
-	 *             If the capacity is &le;0.
-	 */
-	public CoinTray(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
-
-		coins = new Coin[capacity];
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
-	 * announced to observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to add.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the tray overflows.
-	 */
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(nextIndex < coins.length) {
-			coins[nextIndex++] = coin;
-			notifyCoinAdded();
-		}
-		else
-			throw new OverloadException("The tray has overflowed.");
-	}
-
-	/**
-	 * Simulates the act of physically removing coins from the try by a user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The list of coins collected. May not be null. May be empty.
-	 */
-	public List<Coin> collectCoins() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		List<Coin> result = Arrays.asList(coins);
-
-		coins = new Coin[coins.length];
-		nextIndex = 0;
-
-		return result;
-	}
-
-	/**
-	 * Returns whether this coin receptacle has enough space to accept at least one
-	 * more coin: always true. Causes no events.
-	 */
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < coins.length;
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinTrayObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
deleted file mode 100644
index f444162..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
+++ /dev/null
@@ -1,268 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.math.BigDecimal;
-import java.util.Collections;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
-
-/**
- * Represents a device for optically and/or physically validating coins. Coins
- * deemed valid are moved to storage; coins deemed invalid are ejected.
- */
-public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
-	public final Currency currency;
-	private List<BigDecimal> denominations;
-	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
-	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
-
-	/**
-	 * Creates a coin validator that recognizes coins of the specified denominations
-	 * (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.size() < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Collections.sort(denominations);
-
-		standardSinks = new HashMap<>();
-
-		for(BigDecimal denomination : denominations) {
-			if(denomination == null)
-				throw new SimulationException(new NullPointerException("A denomination is null"));
-
-			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(standardSinks.containsKey(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			standardSinks.put(denomination, null);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param rejectionSink
-	 *            The channel to which rejected coins are routed.
-	 * @param overflowSink
-	 *            The channel to which valid coins are routed when the normal sink
-	 *            is full.
-	 * @param standardSinks
-	 *            The channels to which valid coins are normally routed. There must
-	 *            be one sink to correspond to each valid currency denomination, and
-	 *            they must be in the same order as the valid denominations.
-	 * @throws SimulationException
-	 *             If any argument is null.
-	 * @throws SimulationException
-	 *             If any standard sink is null.
-	 * @throws SimulationException
-	 *             If the number of standard sinks differs from the number of
-	 *             denominations.
-	 * @throws SimulationException
-	 *             If any sink is used in more than one position.
-	 */
-	public void connect(UnidirectionalChannel<Coin> rejectionSink,
-		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		if(rejectionSink == null)
-			throw new SimulationException(
-				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
-
-		if(overflowSink == null)
-			throw new SimulationException(
-				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
-
-		if(standardSinks == null)
-			throw new SimulationException(
-				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
-
-		if(standardSinks.keySet().size() != denominations.size())
-			throw new SimulationException(
-				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
-
-		this.rejectionSink = rejectionSink;
-		this.overflowSink = overflowSink;
-
-		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
-
-		for(BigDecimal denomination : standardSinks.keySet()) {
-			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
-			if(sink == null)
-				throw new SimulationException(
-					new NullPointerException("The sink for denomination " + denomination + " is null."));
-			else {
-				if(set.contains(sink))
-					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-				set.add(sink);
-			}
-		}
-
-		this.standardSinks = standardSinks;
-
-		if(set.contains(rejectionSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-		else
-			set.add(rejectionSink);
-
-		if(set.contains(overflowSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-		this.overflowSink = overflowSink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Coin coin) {
-		if(currency.equals(coin.getCurrency()))
-			for(BigDecimal denomination : denominations)
-				if(denomination.equals(coin.getValue()))
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the coin validator that the indicated coin is being inserted. If the
-	 * coin is valid, a "validCoinDetected" event is announced to its observers;
-	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
-	 * <p>
-	 * If there is space in the machine to store a valid coin, it is passed to the
-	 * sink channel corresponding to the denomination of the coin.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the coin is invalid, the
-	 * coin is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the coin validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the coin is null.
-	 * @throws SimulationException
-	 *             If the coin cannot be delivered.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(isValid(coin)) {
-			notifyValidCoinDetected(coin);
-
-			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					rejectionSink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidCoinDetected(coin);
-
-			try {
-				rejectionSink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
-	}
-
-	private void notifyValidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.validCoinDetected(this, coin.getValue());
-	}
-
-	private void notifyInvalidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.invalidCoinDetected(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
deleted file mode 100644
index 7fce25d..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Issued when a device cannot perform its usual functions because it has been
- * disabled.
- */
-@SuppressWarnings("serial")
-public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
deleted file mode 100644
index f6c0b47..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
+++ /dev/null
@@ -1,171 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-
-public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
-	private ArrayList<Item> items = new ArrayList<>();
-
-	private double weightLimitInGrams;
-	private double currentWeightInGrams = 0;
-	private double weightAtLastEvent = 0;
-	private double sensitivity;
-
-	/**
-	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload.
-	 * 
-	 * @param weightLimitInGrams
-	 *            The weight threshold beyond which the scale will overload.
-	 * @param sensitivity
-	 *            The number of grams that can be added or removed since the last
-	 *            change event, without causing a new change event.
-	 * @throws SimulationException
-	 *             If either argument is &le;0.
-	 */
-	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
-		if(weightLimitInGrams <= 0)
-			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
-
-		if(sensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
-
-		this.weightLimitInGrams = weightLimitInGrams;
-		this.sensitivity = sensitivity;
-	}
-
-	/**
-	 * Gets the weight limit for the scale.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The weight limit.
-	 */
-	public double getWeightLimit() {
-		return weightLimitInGrams;
-	}
-
-	/**
-	 * Gets the current weight on the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The current weight.
-	 * @throws OverloadException
-	 *             If the weight has overloaded the scale.
-	 */
-	public double getCurrentWeight() throws OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams;
-
-		throw new OverloadException();
-	}
-
-	/**
-	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
-	 * noticed or announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The sensitivity.
-	 */
-	public double getSensitivity() {
-		return sensitivity;
-	}
-
-	/**
-	 * Adds an item to the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to add.
-	 * @throws SimulationException
-	 *             If the same item is added more than once.
-	 */
-	public void add(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(items.contains(item))
-			throw new SimulationException("The same item cannot be added more than once to the scale.");
-
-		currentWeightInGrams += item.getWeight();
-
-		items.add(item);
-
-		if(currentWeightInGrams > weightLimitInGrams)
-			notifyOverload();
-		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
-			notifyWeightChanged();
-	}
-
-	/**
-	 * Removes an item from the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to remove.
-	 * @throws SimulationException
-	 *             If the item is not on the scale.
-	 */
-	public void remove(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(!items.remove(item))
-			throw new SimulationException("The item was not found amongst those on the scale.");
-
-		// To avoid drift in the sum due to round-off error, recalculate the weight.
-		double newWeightInGrams = 0.0;
-		for(Item itemOnScale : items)
-			newWeightInGrams += itemOnScale.getWeight();
-
-		double original = currentWeightInGrams;
-		currentWeightInGrams = newWeightInGrams;
-
-		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
-			notifyOutOfOverload();
-
-		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
-			notifyWeightChanged();
-	}
-
-	private void notifyOverload() {
-		for(ElectronicScaleObserver l : observers)
-			l.overload(this);
-	}
-
-	private void notifyOutOfOverload() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.outOfOverload(this);
-	}
-
-	private void notifyWeightChanged() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.weightChanged(this, currentWeightInGrams);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
deleted file mode 100644
index e4942a1..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple base interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface Emitter<T> {
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
deleted file mode 100644
index f8564db..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Represents the situation when a device is emptied but an attempt is made to
- * remove something from it.
- */
-public class EmptyException extends Exception {
-	private static final long serialVersionUID = 3566954386000387724L;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
deleted file mode 100644
index 089d324..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FlowThroughEmitter<T> {
-	/**
-	 * Instructs the device to emit a specific thing, meaning that the device is
-	 * being handed this thing to pass onwards.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to emit.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit(T thing) throws DisabledException, OverloadException;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
deleted file mode 100644
index 5fb3376..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FromStorageEmitter<T> {
-	/**
-	 * Instructs the device to emit one thing, meaning that the device stores a set
-	 * of things and one of them is to be emitted.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws EmptyException
-	 *             If the device is empty and cannot emit.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit() throws DisabledException, EmptyException, OverloadException;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
deleted file mode 100644
index 7fcc01d..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Represents situations where a device has been overloaded, in terms of weight,
- * quantity of items, etc.
- */
-public class OverloadException extends Exception {
-	private static final long serialVersionUID = 7813659161520664284L;
-
-	/**
-	 * Create an exception without an error message.
-	 */
-	public OverloadException() {}
-
-	/**
-	 * Create an exception with an error message.
-	 * 
-	 * @param message
-	 *            The error message to use.
-	 */
-	public OverloadException(String message) {
-		super(message);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
deleted file mode 100644
index e1c16e6..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
+++ /dev/null
@@ -1,204 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
-
-/**
- * Represents printers used for printing receipts. A printer has a finite amount
- * of paper (measured in lines that can be printed) and ink (measured in
- * characters that can be printed).
- * <p>
- * Since this is a simulation, each character is assumed to require the same
- * amount of ink (except blanks and newlines) and the font size is fixed.
- * </p>
- */
-public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
-	public static final int MAXIMUM_INK = 1 << 20;
-	public static final int MAXIMUM_PAPER = 1 << 10;
-	private int charactersOfInkRemaining = 0;
-	private int linesOfPaperRemaining = 0;
-	private StringBuilder sb = new StringBuilder();
-	private int charactersOnCurrentLine = 0;
-
-	/**
-	 * Represents the maximum number of characters that can fit on one line of the
-	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
-	 * size.
-	 */
-	public final static int CHARACTERS_PER_LINE = 60;
-
-	/**
-	 * Creates a receipt printer.
-	 */
-	public ReceiptPrinter() {}
-
-	/**
-	 * Prints a single character to the receipt. Whitespace characters are ignored,
-	 * with the exception of ' ' (blank) and '\n', which signals to move to the
-	 * start of the next line.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param c
-	 *            The character to print.
-	 * @throws SimulationException
-	 *             If there is no ink or no paper in the printer.
-	 * @throws SimulationException
-	 *             If the extra character would spill off the end of the line.
-	 */
-	public void print(char c) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(c == '\n') {
-			--linesOfPaperRemaining;
-			charactersOnCurrentLine = 0;
-		}
-		else if(c != ' ' && Character.isWhitespace(c))
-			return;
-		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
-			throw new SimulationException("The line is too long. Add a newline");
-		else if(linesOfPaperRemaining == 0)
-			throw new SimulationException("There is no paper in the printer.");
-		else
-			charactersOnCurrentLine++;
-
-		if(!Character.isWhitespace(c)) {
-			if(charactersOfInkRemaining == 0)
-				throw new SimulationException("There is no ink in the printer");
-
-			charactersOfInkRemaining--;
-		}
-
-		sb.append(c);
-
-		if(charactersOfInkRemaining == 0)
-			notifyOutOfInk();
-
-		if(linesOfPaperRemaining == 0)
-			notifyOutOfPaper();
-	}
-
-	/**
-	 * The receipt is finished printing, so cut it so that the customer can easily
-	 * remove it. Failure to cut the paper means that the receipt will not be
-	 * retrievable by the customer.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public void cutPaper() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		lastReceipt = sb.toString();
-	}
-
-	private String lastReceipt = null;
-
-	/**
-	 * Simulates the customer removing the receipt. Failure to cut the receipt
-	 * first, or to always remove the receipt means that the customer will end up
-	 * with other customers' receipts too!
-	 * 
-	 * @return The receipt if it has been cut; otherwise, null.
-	 */
-	public String removeReceipt() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		String receipt = lastReceipt;
-
-		if(lastReceipt != null) {
-			lastReceipt = null;
-			sb = new StringBuilder();
-		}
-		else
-			throw new SimulationException("A non-existent receipt cannot be removed.");
-
-		return receipt;
-	}
-
-	/**
-	 * Adds ink to the printer. Simulates a human doing the adding.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param quantity
-	 *            The quantity of characters-worth of ink to add.
-	 * @throws SimulationException
-	 *             If the quantity is negative.
-	 * @throws SimulationException
-	 *             If the total of the existing ink plus the added quantity is
-	 *             greater than the printer's capacity.
-	 */
-	public void addInk(int quantity) {
-		if(quantity < 0)
-			throw new SimulationException("Are you trying to remove ink?");
-
-		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
-			throw new SimulationException("You spilled a bunch of ink!");
-
-		if(quantity > 0) {
-			charactersOfInkRemaining += quantity;
-			notifyInkAdded();
-		}
-	}
-
-	/**
-	 * Adds paper to the printer. Simulates a human doing the adding.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param quantity
-	 *            The quantity of lines-worth of paper to add.
-	 * @throws SimulationException
-	 *             If the quantity is negative.
-	 * @throws SimulationException
-	 *             If the total of the existing paper plus the added quantity is
-	 *             greater than the printer's capacity.
-	 */
-	public void addPaper(int units) {
-		if(units < 0)
-			throw new SimulationException("Are you trying to remove paper?");
-
-		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
-			throw new SimulationException("You may have broken the printer, jamming so much in there!");
-
-		if(units > 0) {
-			linesOfPaperRemaining += units;
-			notifyPaperAdded();
-		}
-	}
-
-	private void notifyOutOfInk() {
-		for(ReceiptPrinterObserver l : observers)
-			l.outOfInk(this);
-	}
-
-	private void notifyInkAdded() {
-		for(ReceiptPrinterObserver l : observers)
-			l.inkAdded(this);
-	}
-
-	private void notifyOutOfPaper() {
-		for(ReceiptPrinterObserver l : observers)
-			l.outOfPaper(this);
-	}
-
-	private void notifyPaperAdded() {
-		for(ReceiptPrinterObserver l : observers)
-			l.paperAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
deleted file mode 100644
index 0356dd2..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
+++ /dev/null
@@ -1,257 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.math.BigDecimal;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.sound.sampled.AudioSystem;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * Simulates the overall self-checkout station.
- * <p>
- * A self-checkout possesses the following units of hardware that the customer
- * can see and interact with:
- * <ul>
- * <li>one electronic scale, with a configurable maximum weight before it
- * overloads;</li>
- * <li>one receipt printer;</li>
- * <li>one card reader;</li>
- * <li>one scanner;</li>
- * <li>one input slot for banknotes;</li>
- * <li>one output slot for banknotes;</li>
- * <li>one input slot for coins;</li>
- * <li>one output tray for coins; and,</li>
- * <li>one speaker for audio output (note: you should directly use the
- * {@link AudioSystem} class, if you want to produce sounds).</li>
- * </ul>
- * </p>
- * <p>
- * In addition, these units of hardware are accessible to personnel with a key
- * to unlock the front of the station:
- * <li>one banknote storage unit, with configurable capacity;</li>
- * <li>one or more banknote dispensers, one for each supported denomination of
- * banknote, as configured;</li>
- * <li>one coin storage unit, with configurable capacity; and,</li>
- * <li>one or more coin dispensers, one for each supported denomination of coin,
- * as configured.</li>
- * </ul>
- * </p>
- * <p>
- * And finally, there are certain, additional units of hardware that would only
- * be accessible to someone with the appropriate tools (like a screwdriver,
- * crowbar, or sledge hammer):
- * <ul>
- * <li>one banknote validator; and</li>
- * <li>one coin validator.</li>
- * </ul>
- * </p>
- * <p>
- * Many of these devices are interconnected, to permit coins or banknotes to
- * pass between them. Specifically:
- * <ul>
- * <li>the coin slot is connected to the coin validator (this is a
- * one-directional chain of devices);</li>
- * <li>the coin validator is connected to each of the coin dispensers (i.e., the
- * coin dispensers can be replenished with coins entered by customers), to the
- * coin storage unit (for any overflow coins that do not fit in the dispensers),
- * and to the coin tray for any rejected coins either because the coins are
- * invalid or because even the overflow storage unit is full (this is a
- * one-directional chain of devices);
- * <li>each coin dispenser is connected to the coin tray, to provide change
- * (this is a one-directional chain of devices);</li>
- * <li>the banknote input slot is connected to the banknote validator (this is a
- * <b>two</b>-directional chain of devices as an entered banknotes that are
- * rejected by the validator can be returned to the customer);</li>
- * <li>the banknote validator is connected to the banknote storage unit (this is
- * a one-directional chain of devices); and,</li>
- * <li>each banknote dispenser is connected to the output banknote slot; these
- * dispensers cannot be replenished by banknotes provided by customers (this is
- * a one-directional chain of devices).</li>
- * </ul>
- * </p>
- * <p>
- * All other functionality of the system must be performed in software,
- * installed on the self-checkout station through custom observer classes
- * implementing the various observer interfaces provided.
- * </p>
- * <p>
- * Note that banknote denominations are required to be positive integers, while
- * coin denominations are positive decimal values ({@link BigDecimal} is used
- * for the latter to avoid roundoff problems arising from floating-point
- * operations).
- */
-public class SelfCheckoutStation {
-	public final ElectronicScale scale;
-	public final ReceiptPrinter printer;
-	public final CardReader cardReader;
-	public final BarcodeScanner scanner;
-
-	public final BanknoteSlot banknoteInput, banknoteOutput;
-	public final BanknoteValidator banknoteValidator;
-	public final BanknoteStorageUnit banknoteStorage;
-	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
-	public final int[] banknoteDenominations;
-	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
-	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
-
-	public final CoinSlot coinSlot;
-	public final CoinValidator coinValidator;
-	public final CoinStorageUnit coinStorage;
-	public static final int COIN_STORAGE_CAPACITY = 1000;
-	public final List<BigDecimal> coinDenominations;
-	public final Map<BigDecimal, CoinDispenser> coinDispensers;
-	public static final int COIN_DISPENSER_CAPACITY = 200;
-	public final CoinTray coinTray;
-	public static final int COIN_TRAY_CAPACITY = 20;
-
-	/**
-	 * Creates a self-checkout station.
-	 * 
-	 * @param currency
-	 *            The kind of currency permitted.
-	 * @param banknoteDenominations
-	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
-	 * @param coinDenominations
-	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
-	 * @param scaleMaximumWeight
-	 *            The most weight that can be placed on the scale before it
-	 *            overloads.
-	 * @param scaleSensitivity
-	 *            Any weight changes smaller than this will not be detected or
-	 *            announced.
-	 * @throws SimulationException
-	 *             If any argument is null or negative.
-	 * @throws SimulationException
-	 *             If the number of banknote or coin denominations is &lt;1.
-	 */
-	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
-		int scaleMaximumWeight, int scaleSensitivity) {
-		if(currency == null || banknoteDenominations == null || coinDenominations == null)
-			throw new SimulationException(new NullPointerException("No argument may be null."));
-
-		if(scaleMaximumWeight <= 0)
-			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
-
-		if(scaleSensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
-
-		if(banknoteDenominations.length == 0)
-			throw new SimulationException(
-				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
-
-		if(coinDenominations.length == 0)
-			throw new SimulationException(
-				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
-
-		// Create the devices.
-		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
-		printer = new ReceiptPrinter();
-		cardReader = new CardReader();
-		scanner = new BarcodeScanner();
-
-		this.banknoteDenominations = banknoteDenominations;
-		banknoteInput = new BanknoteSlot(false);
-		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
-		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
-		banknoteOutput = new BanknoteSlot(true);
-
-		banknoteDispensers = new HashMap<>();
-
-		for(int i = 0; i < banknoteDenominations.length; i++)
-			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
-
-		this.coinDenominations = Arrays.asList(coinDenominations);
-		coinSlot = new CoinSlot();
-		coinValidator = new CoinValidator(currency, this.coinDenominations);
-		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
-		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
-
-		coinDispensers = new HashMap<>();
-
-		for(int i = 0; i < coinDenominations.length; i++)
-			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
-
-		// Hook up everything.
-		interconnect(banknoteInput, banknoteValidator);
-		interconnect(banknoteValidator, banknoteStorage);
-
-		for(BanknoteDispenser dispenser : banknoteDispensers.values())
-			interconnect(dispenser, banknoteOutput);
-
-		interconnect(coinSlot, coinValidator);
-		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
-
-		for(CoinDispenser coinDispenser : coinDispensers.values())
-			interconnect(coinDispenser, coinTray);
-
-		scale.endConfigurationPhase();
-		printer.endConfigurationPhase();
-		cardReader.endConfigurationPhase();
-		scanner.endConfigurationPhase();
-
-		banknoteInput.endConfigurationPhase();
-		banknoteValidator.endConfigurationPhase();
-		banknoteStorage.endConfigurationPhase();
-		banknoteOutput.endConfigurationPhase();
-
-		for(BanknoteDispenser bd : banknoteDispensers.values())
-			bd.endConfigurationPhase();
-
-		coinSlot.endConfigurationPhase();
-		coinValidator.endConfigurationPhase();
-		coinStorage.endConfigurationPhase();
-		coinTray.endConfigurationPhase();
-
-		for(CoinDispenser cd : coinDispensers.values())
-			cd.endConfigurationPhase();
-	}
-
-	private BidirectionalChannel<Banknote> validatorSource;
-
-	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
-		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
-		slot.connect(validatorSource);
-	}
-
-	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
-		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
-		validator.connect(validatorSource, bc);
-	}
-
-	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
-		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
-		dispenser.connect(bc);
-	}
-
-	private void interconnect(CoinSlot slot, CoinValidator validator) {
-		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
-		slot.connect(cc);
-	}
-
-	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
-		CoinStorageUnit storage) {
-		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
-		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
-
-		for(BigDecimal denomination : dispensers.keySet()) {
-			CoinDispenser dispenser = dispensers.get(denomination);
-			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
-		}
-
-		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
-
-		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
-	}
-
-	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
-		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
-		dispenser.connect(cc);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
deleted file mode 100644
index 7001f20..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * An exception that can be raised when the behaviour within the simulator makes
- * no sense, typically when it has not been configured correctly. This is
- * different from an exception being raised because the preconditions of a
- * component are violated, but that would make sense in the real world.
- */
-@SuppressWarnings("serial")
-public class SimulationException extends RuntimeException {
-	private String nested;
-
-	/**
-	 * Constructor used to nest other exceptions.
-	 * 
-	 * @param nested
-	 *            An underlying exception that is to be wrapped.
-	 */
-	public SimulationException(Exception nested) {
-		this.nested = nested.toString();
-	}
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param message
-	 *            An explanatory message of the problem.
-	 */
-	public SimulationException(String message) {
-		nested = message;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
deleted file mode 100644
index 888ab32..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * Represents a simple device (like, say, a tube) that allows things to move in
- * one direction between other devices.
- * 
- * @param <T>
- *            The type of the things to be transported.
- */
-public class UnidirectionalChannel<T> {
-	private Acceptor<T> sink;
-
-	/**
-	 * Constructs a new coin channel whose output is connected to the indicated
-	 * sink.
-	 * 
-	 * @param sink
-	 *            The device at the output end of the channel.
-	 */
-	public UnidirectionalChannel(Acceptor<T> sink) {
-		this.sink = sink;
-	}
-
-	/**
-	 * Moves the indicated thing to the sink. This method should be called by the
-	 * source device, and not by an external application.
-	 * 
-	 * @param thing
-	 *            The thing to transport via the channel.
-	 * @throws OverloadException
-	 *             If the sink has no space for the thing.
-	 * @throws DisabledException
-	 *             If the sink is currently disabled.
-	 */
-	public void deliver(T thing) throws OverloadException, DisabledException {
-		sink.accept(thing);
-	}
-
-	/**
-	 * Returns whether the sink has space for at least one more thing.
-	 * 
-	 * @return true if the channel can accept a thing; false otherwise.
-	 */
-	public boolean hasSpace() {
-		return sink.hasSpace();
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
deleted file mode 100644
index 5faa152..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-
-/**
- * This class represents the abstract interface for all device observers. All
- * subclasses should add their own event notification methods, the first
- * parameter of which should always be the device affected.
- */
-public interface AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated device has been enabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-
-	/**
-	 * Announces that the indicated device has been disabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
deleted file mode 100644
index 08d8fcd..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteDispenser;
-
-/**
- * Observes events emanating from a banknote dispenser.
- */
-public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote dispenser is full of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void moneyFull(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote dispenser is empty of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void banknotesEmpty(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was added.
-	 */
-	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was removed.
-	 */
-	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been added to the
-	 * indicated banknote dispenser. Used to simulate direct, physical loading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were loaded.
-	 */
-	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been removed to the
-	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were unloaded.
-	 */
-	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
deleted file mode 100644
index f690ec9..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
-
-/**
- * Observes events emanating from a banknote slot.
- */
-public interface BanknoteSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a banknote has been inserted.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteInserted(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a banknote has been returned to the user, dangling
-	 * from the slot.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteEjected(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a dangling banknote has been removed by the user.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteRemoved(BanknoteSlot slot);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
deleted file mode 100644
index d4087a5..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
-
-/**
- * Observes events emanating from a banknote storage unit.
- */
-public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote storage unit is full of banknotes.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesFull(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that a banknote has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknoteAdded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with banknotes.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesLoaded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of banknotes. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesUnloaded(BanknoteStorageUnit unit);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
deleted file mode 100644
index d63191a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteValidator;
-
-/**
- * Observes events emanating from a banknote validator.
- */
-public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be valid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 * @param currency
-	 *            The kind of currency of the inserted banknote.
-	 * @param value
-	 *            The value of the inserted banknote.
-	 */
-	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
-
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be invalid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 */
-	void invalidBanknoteDetected(BanknoteValidator validator);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
deleted file mode 100644
index e3945d0..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
-
-/**
- * Observes events emanating from a barcode scanner.
- */
-public interface BarcodeScannerObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated barcode has been successfully scanned.
-	 * 
-	 * @param barcodeScanner
-	 *            The device on which the event occurred.
-	 * @param barcode
-	 *            The barcode that was read by the scanner.
-	 */
-	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
-
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
deleted file mode 100644
index 173be6c..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.devices.CardReader;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CardReaderObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that a card has been inserted in the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardInserted(CardReader reader);
-
-	/**
-	 * Announces that a card has been removed from the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardRemoved(CardReader reader);
-
-	/**
-	 * Announces that a (tap-enabled) card has been tapped on the indicated card
-	 * reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardTapped(CardReader reader);
-
-	/**
-	 * Announces that a card has swiped on the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardSwiped(CardReader reader);
-
-	/**
-	 * Announces that the data has been read from a card.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 * @param data
-	 *            The data that was read. Note that this data may be corrupted.
-	 */
-	void cardDataRead(CardReader reader, CardData data);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
deleted file mode 100644
index 2494e38..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinDispenser;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CoinDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin dispenser is full of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsFull(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin dispenser is empty of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsEmpty(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was added.
-	 */
-	void coinAdded(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was removed.
-	 */
-	void coinRemoved(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated sequence of coins has been added to the
-	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were loaded.
-	 */
-	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
-
-	/**
-	 * Announces that the indicated sequence of coins has been removed to the
-	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were unloaded.
-	 */
-	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
deleted file mode 100644
index 75900f2..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinSlot;
-
-/**
- * Observes events emanating from a coin slot.
- */
-public interface CoinSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a coin has been inserted.
-	 * 
-	 * @param slot
-	 *             The device on which the event occurred.
-	 */
-	void coinInserted(CoinSlot slot);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
deleted file mode 100644
index 4c6f974..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinStorageUnit;
-
-/**
- * Observes events emanating from a coin storage unit.
- */
-public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin storage unit is full of coins.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsFull(CoinStorageUnit unit);
-
-	/**
-	 * Announces that a coin has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinAdded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with coins.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsLoaded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of coins. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsUnloaded(CoinStorageUnit unit);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
deleted file mode 100644
index 5a67bb4..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinTray;
-
-/**
- * Observes events emanating from a coin tray. Coin trays are dumb devices so
- * very few kinds of events can be announced by them.
- */
-public interface CoinTrayObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that a coin has been added to the indicated tray.
-	 * 
-	 * @param tray
-	 *            The tray where the event occurred.
-	 */
-	void coinAdded(CoinTray tray);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
deleted file mode 100644
index 7229824..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinValidator;
-
-/**
- * Observes events emanating from a coin validator.
- */
-public interface CoinValidatorObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated coin has been detected and determined
-	 * to be valid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 * @param value
-	 *            The value of the coin.
-	 */
-	void validCoinDetected(CoinValidator validator, BigDecimal value);
-
-	/**
-	 * An event announcing that a coin has been detected and determined to be
-	 * invalid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 */
-	void invalidCoinDetected(CoinValidator validator);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
deleted file mode 100644
index dcbdb49..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-
-/**
- * Observes events emanating from an electronic scale.
- */
-public interface ElectronicScaleObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the weight on the indicated scale has changed.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 * @param weightInGrams
-	 *            The new weight.
-	 */
-	void weightChanged(ElectronicScale scale, double weightInGrams);
-
-	/**
-	 * Announces that excessive weight has been placed on the indicated scale.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 */
-	void overload(ElectronicScale scale);
-
-	/**
-	 * Announces that the former excessive weight has been removed from the
-	 * indicated scale, and it is again able to measure weight.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 */
-	void outOfOverload(ElectronicScale scale);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
deleted file mode 100644
index 16e810f..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.ReceiptPrinter;
-
-/**
- * Observes events emanating from a receipt printer.
- */
-public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated printer is out of paper.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void outOfPaper(ReceiptPrinter printer);
-
-	/**
-	 * Announces that the indicated printer is out of ink.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void outOfInk(ReceiptPrinter printer);
-
-	/**
-	 * Announces that paper has been added to the indicated printer.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void paperAdded(ReceiptPrinter printer);
-
-	/**
-	 * Announces that ink has been added to the indicated printer.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void inkAdded(ReceiptPrinter printer);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
deleted file mode 100644
index d630fea..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-
-/**
- * Represents observers that respond only to enable/disable events on touch screens.
- */
-public interface TouchScreenObserver extends AbstractDeviceObserver {
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
deleted file mode 100644
index 794b53a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents products with barcodes. Such products always have prices per-unit.
- */
-public class BarcodedProduct extends Product {
-	private final Barcode barcode;
-	private final String description;
-
-	/**
-	 * Create a product.
-	 * 
-	 * @param barcode
-	 *            The barcode of the product.
-	 * @param description
-	 *            The description of the product.
-	 * @param price
-	 *            The price per-unit of the product.
-	 * @throws SimulationException
-	 *             If any argument is null.
-	 * @throws SimulationException
-	 *             If the price is &le;0.
-	 */
-	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
-		super(price, true);
-
-		if(barcode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		if(description == null)
-			throw new SimulationException(new NullPointerException("description is null"));
-
-		this.barcode = barcode;
-		this.description = description;
-	}
-
-	/**
-	 * Get the barcode.
-	 * 
-	 * @return The barcode. Cannot be null.
-	 */
-	public Barcode getBarcode() {
-		return barcode;
-	}
-
-	/**
-	 * Get the description.
-	 * 
-	 * @return The description. Cannot be null.
-	 */
-	public String getDescription() {
-		return description;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
deleted file mode 100644
index ef28888..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.PriceLookupCode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents products with price-lookup (PLU) codes. Such products always have
- * prices per-kilogram.
- */
-public class PLUCodedProduct extends Product {
-	private final PriceLookupCode pluCode;
-	private final String description;
-
-	/**
-	 * Create a product.
-	 * 
-	 * @param pluCode
-	 *            The PLU code of the product.
-	 * @param description
-	 *            The description of the product.
-	 * @param price
-	 *            The price per-kilogram of the product.
-	 */
-	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
-		super(price, false);
-
-		if(pluCode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		if(description == null)
-			throw new SimulationException(new NullPointerException("description is null"));
-
-		this.pluCode = pluCode;
-		this.description = description;
-	}
-
-	/**
-	 * Get the PLU code.
-	 * 
-	 * @return The PLU code. Cannot be null.
-	 */
-	public PriceLookupCode getPLUCode() {
-		return pluCode;
-	}
-
-	/**
-	 * Get the description.
-	 * 
-	 * @return The description. Cannot be null.
-	 */
-	public String getDescription() {
-		return description;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
deleted file mode 100644
index cd7ccb4..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java	
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Abstract base class for products. Note that a "product" is the <b>kind</> of
- * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
- * individual item, which would be the specific physical object (e.g.,
- * <b>that</b> bottle of milk and not <b>this</b> one).
- */
-public abstract class Product {
-	private final BigDecimal price;
-	private final boolean isPerUnit;
-
-	/**
-	 * Create a product instance.
-	 * 
-	 * @param price
-	 *            The price per unit or per kilogram.
-	 * @param isPerUnit
-	 *            True if the price is per unit; false if it is per kilogram.
-	 * @throws SimulationException
-	 *             If the price is null or &le;0.
-	 */
-	protected Product(BigDecimal price, boolean isPerUnit) {
-		if(price == null)
-			throw new SimulationException(new NullPointerException("price is null"));
-
-		if(price.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
-
-		this.price = price;
-		this.isPerUnit = isPerUnit;
-	}
-
-	/**
-	 * Gets the price of the product.
-	 * 
-	 * @return The price. Cannot be null. Must be &gt;0.
-	 */
-	public BigDecimal getPrice() {
-		return price;
-	}
-
-	/**
-	 * Tests whether the price is per-unit, as opposed to per-kilogram.
-	 * 
-	 * @return true if the price is per-unit; otherwise, false.
-	 */
-	public boolean isPerUnit() {
-		return isPerUnit;
-	}
-}

commit ef5f15bbff4c2e58fe5c06cd234154c9237d09d9
Author: staytheknight <staytheknight@gmail.com>
Date:   Mon Mar 14 13:41:53 2022 -0600

    Added project source code to be worked from

diff --git a/.classpath b/.classpath
index d58936f..fdd2993 100644
--- a/.classpath
+++ b/.classpath
@@ -6,6 +6,7 @@
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
 	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v1.0/.classpath
new file mode 100644
index 0000000..04cc82d
--- /dev/null
+++ b/SCS - Hardware - v1.0/.classpath	
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v1.0/.project
new file mode 100644
index 0000000..fd60f0c
--- /dev/null
+++ b/SCS - Hardware - v1.0/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Hardware - v1.0</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..3a21537
--- /dev/null
+++ b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..de514e7
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..a9314d0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..4c8882f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..aba29ee
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..f91d858
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java	
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b8e1f7c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java	
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..fab9792
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..3b6416e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..58da94a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java	
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..00c7c18
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..ede38a9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java	
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..22e6f63
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..7134225
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..24e2842
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java	
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..fc5396e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..c53e6f7
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..e0985d0
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..c860edc
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..66ea14e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..20cb12a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..d3890b1
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..df4e37e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..e8f30e4
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..d773a2b
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..fc32c76
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..7e926a5
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..433dc07
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..6f54d0d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..838766e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..9cc3516
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..97d5929
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..3ee4da7
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..f444162
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..7fce25d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..f6c0b47
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..e4942a1
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..f8564db
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..089d324
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..5fb3376
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..7fcc01d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..e1c16e6
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..0356dd2
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -0,0 +1,257 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>one scanner;</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale scale;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner scanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		scanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		scale.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		scanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..7001f20
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..888ab32
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..5faa152
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..08d8fcd
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..f690ec9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..d4087a5
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..d63191a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..e3945d0
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..173be6c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..2494e38
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..75900f2
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..4c6f974
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..5a67bb4
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..7229824
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..dcbdb49
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..16e810f
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..d630fea
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..794b53a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.barcode = barcode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..ef28888
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..cd7ccb4
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java	
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}

commit 225bfbb8b09ee9434f2262f780bf3a81ec65b9bf
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 13 17:23:59 2022 -0600

    added method stubs

diff --git a/.classpath b/.classpath
index 7d3b4d8..d58936f 100644
--- a/.classpath
+++ b/.classpath
@@ -6,5 +6,6 @@
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/bin/org/control/software/Checkout.class b/bin/org/control/software/Checkout.class
new file mode 100644
index 0000000..c48326d
Binary files /dev/null and b/bin/org/control/software/Checkout.class differ
diff --git a/bin/org/control/software/Payment.class b/bin/org/control/software/Payment.class
new file mode 100644
index 0000000..214152d
Binary files /dev/null and b/bin/org/control/software/Payment.class differ
diff --git a/bin/org/control/software/Scan.class b/bin/org/control/software/Scan.class
new file mode 100644
index 0000000..60b7b05
Binary files /dev/null and b/bin/org/control/software/Scan.class differ
diff --git a/src/org/control/software/Checkout.java b/src/org/control/software/Checkout.java
new file mode 100644
index 0000000..b92be6e
--- /dev/null
+++ b/src/org/control/software/Checkout.java
@@ -0,0 +1,9 @@
+package org.control.software;
+
+public class Checkout {
+	
+	public void checkout() {
+		
+	}
+
+}
diff --git a/src/org/control/software/Payment.java b/src/org/control/software/Payment.java
new file mode 100644
index 0000000..a131ccf
--- /dev/null
+++ b/src/org/control/software/Payment.java
@@ -0,0 +1,17 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.Banknote;
+
+public class Payment {
+	
+	Banknote bn = new Banknote(null, 0);
+	
+	public void payWithCoin() {
+		
+	}
+	
+	public void payWithBanknote() {
+		
+	}
+
+}
diff --git a/src/org/control/software/Scan.java b/src/org/control/software/Scan.java
new file mode 100644
index 0000000..2587fe8
--- /dev/null
+++ b/src/org/control/software/Scan.java
@@ -0,0 +1,13 @@
+package org.control.software;
+
+public class Scan {
+	
+	public void itemScanned() {
+		
+	}
+	
+	public void itemBagged() {
+		
+	}
+
+}

commit 8da2bfaa3c88a4901906613727e0e7ff25e5d097
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Thu Mar 10 11:46:29 2022 -0700

    first commit

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..7d3b4d8
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-15">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..711bba8
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..223b166
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=15
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=15
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=15
