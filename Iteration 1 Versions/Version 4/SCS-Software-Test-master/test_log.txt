commit bf2a32b1e2c323f61f9b95af338fea88d4cc8613
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:56:46 2022 -0600

    final commit

diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
index 476aafc..cded795 100644
Binary files a/bin/org/control/software/CoinSlotControlObserver.class and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 0166df9..3a58900 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 447a1ed..8ca8cf6 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index f025a0e..58ab809 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/bin/test/control/software/CustomerScanItemTest.class b/bin/test/control/software/CustomerScanItemTest.class
index 29ed027..c9415fb 100644
Binary files a/bin/test/control/software/CustomerScanItemTest.class and b/bin/test/control/software/CustomerScanItemTest.class differ
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
index 905e268..e9550c2 100644
--- a/src/org/control/software/CoinSlotControlObserver.java
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -1,7 +1,6 @@
 package org.control.software;
-import java.math.BigDecimal;
-import java.util.Currency;
 
+import java.math.BigDecimal;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index b4ce98c..627c5af 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -1,7 +1,6 @@
 package org.control.software;
-import java.math.BigDecimal;
-import java.util.Currency;
 
+import java.math.BigDecimal;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index 97453e3..da4b819 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -6,7 +6,6 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 
 
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index dae2a73..a313ce2 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -1,7 +1,5 @@
 package test.control.software;
 
-import static org.junit.Assert.*;
-
 import org.control.software.CheckoutController;
 import org.control.software.ReceiptPrinterControlObserver;
 import org.junit.Assert;
diff --git a/src/test/control/software/CustomerScanItemTest.java b/src/test/control/software/CustomerScanItemTest.java
index 2c73f5b..6c1b565 100644
--- a/src/test/control/software/CustomerScanItemTest.java
+++ b/src/test/control/software/CustomerScanItemTest.java
@@ -1,7 +1,5 @@
 package test.control.software;
 
-import static org.junit.Assert.*;
-
 import org.control.software.ItemsCollection;
 import org.control.software.ProductsCollection;
 import org.junit.Assert;
@@ -13,9 +11,6 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.devices.SimulationException;
 
-import java.util.ArrayList;
-import java.util.Set;
-
 public class CustomerScanItemTest {
 	Barcode testBarcode;
 	

commit 5e65cbc5cb70c885c72036e687c9d9532bfa7cfc
Author: staytheknight <staytheknight@gmail.com>
Date:   Sun Mar 20 22:52:28 2022 -0600

    Out of Ink and Paper printer test files

diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index d0a6cb6..f025a0e 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/src/org/control/software/ReceiptPrinterControlObserver.java b/src/org/control/software/ReceiptPrinterControlObserver.java
index 81d4121..d1b3db4 100644
--- a/src/org/control/software/ReceiptPrinterControlObserver.java
+++ b/src/org/control/software/ReceiptPrinterControlObserver.java
@@ -12,8 +12,8 @@ import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
 public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
 	
 	private SelfCheckoutStation checkoutStation;
-	boolean outOfPaper;
-	boolean outOfInk;
+	public boolean outOfPaper;
+	public boolean outOfInk;
 	
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index f56672c..dae2a73 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -3,8 +3,10 @@ package test.control.software;
 import static org.junit.Assert.*;
 
 import org.control.software.CheckoutController;
+import org.control.software.ReceiptPrinterControlObserver;
 import org.junit.Assert;
 import org.junit.Test;
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
 
 public class CheckoutTest {
 
@@ -13,6 +15,26 @@ public class CheckoutTest {
 		CheckoutController c = new CheckoutController();
 		Assert.assertTrue(c.checkout());
 	}
+	
+	
+	// Tests if the observer is seeing the correct flag of out of paper
+	@Test
+	public void noPaper() {
+		ReceiptPrinterControlObserver printerOb = new ReceiptPrinterControlObserver();
+		ReceiptPrinter printer = new ReceiptPrinter();
+			printerOb.outOfPaper(printer);
+			Assert.assertTrue(printerOb.outOfPaper);
+	
+	}
+	// Tests if the observer is seeing the correct flag of out of paper
+	@Test
+	public void noInk() {
+		ReceiptPrinterControlObserver printerOb = new ReceiptPrinterControlObserver();
+		ReceiptPrinter printer = new ReceiptPrinter();
+			printerOb.outOfInk(printer);
+			Assert.assertTrue(printerOb.outOfInk);
+	
+	}
 
 }
 

commit bb43cd2425dd77437c3bb17bd7c27a422539f3b4
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:40:37 2022 -0600

    added checkout test case

diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 4592961..d0a6cb6 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/src/org/control/software/CheckoutController.java b/src/org/control/software/CheckoutController.java
index 132b078..bb10a9a 100644
--- a/src/org/control/software/CheckoutController.java
+++ b/src/org/control/software/CheckoutController.java
@@ -7,12 +7,14 @@ public class CheckoutController {
 	BanknoteValidatorControlObserver banknoteValidator = new BanknoteValidatorControlObserver();
 	CoinValidatorControlObserver coinValidator = new CoinValidatorControlObserver();
 	ReceiptPrinterControlObserver receiptPrinter = new ReceiptPrinterControlObserver();
-	private SelfCheckoutStation checkoutStation;
+	public SelfCheckoutStation checkoutStation;
+	public boolean checkedOut;
 	
-	public void checkout() {
+	public boolean checkout() {
 		
 		int checkoutTotal = banknoteValidator.totalValue + coinValidator.totalValue;
 		checkoutStation.printer.print('C');
+		return checkedOut = true;
 		
 	}
 	
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index 2cc5460..f56672c 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -1,19 +1,18 @@
 package test.control.software;
 
 import static org.junit.Assert.*;
-import org.control.software.ProductsCollection;
-import org.control.software.ItemsCollection;
+
+import org.control.software.CheckoutController;
 import org.junit.Assert;
-import org.junit.Before;
 import org.junit.Test;
-import org.junit.Rule;
-import org.junit.rules.ExpectedException;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
 
 public class CheckoutTest {
 
+	@Test
+	public void test() {
+		CheckoutController c = new CheckoutController();
+		Assert.assertTrue(c.checkout());
+	}
 
 }
+

commit 9a1d66abfbf1d70fc75cc2952b76fdfcc1c7d72c
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:29:35 2022 -0600

    resolved errors

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 355ff85..588fb6a 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index d799f1e..447a1ed 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/bin/test/control/software/CustomerScanItemTest.class b/bin/test/control/software/CustomerScanItemTest.class
index 8f26cfe..29ed027 100644
Binary files a/bin/test/control/software/CustomerScanItemTest.class and b/bin/test/control/software/CustomerScanItemTest.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index f6ee08d..12fb2db 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -9,7 +9,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 
 public class ItemsCollection extends Item {
 	
-	double weightInGrams;
+	public double weightInGrams;
 	
 	Map<Barcode, Double> weightsMap = new HashMap<Barcode, Double>();
 
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	public ItemsCollection(Barcode barcode, Double weightInGrams) {
+	public ItemsCollection(Barcode barcode, Double weightInGrams) throws NullPointerException {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index af69e3d..97453e3 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -21,8 +21,8 @@ public class ProductsCollection {
 	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
 	Map<Barcode, ItemsCollection> itemsMap = new HashMap<Barcode, ItemsCollection>();
 	
-	Barcode milkBarcode;
-	Barcode riceBarcode;
+	public Barcode milkBarcode;
+	public Barcode riceBarcode;
 	
 	/**
 	 * Constructor that initializes products collection.
diff --git a/src/test/control/software/CustomerScanItemTest.java b/src/test/control/software/CustomerScanItemTest.java
index b17313f..2c73f5b 100644
--- a/src/test/control/software/CustomerScanItemTest.java
+++ b/src/test/control/software/CustomerScanItemTest.java
@@ -13,6 +13,9 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.devices.SimulationException;
 
+import java.util.ArrayList;
+import java.util.Set;
+
 public class CustomerScanItemTest {
 	Barcode testBarcode;
 	
@@ -22,11 +25,6 @@ public class CustomerScanItemTest {
 		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};		
 		Barcode testBarcode = new Barcode(n);
 	}
-
-	@Test
-	public void test() {
-		fail("Not yet implemented");
-	}
 	
 	// TODO : Products collection properly instantiates items.
 	// Not complete
@@ -34,13 +32,16 @@ public class CustomerScanItemTest {
 	public void test2() {
 		ProductsCollection pCollection = new ProductsCollection();
 		pCollection.initializeProducts();
+		//Assert.assertEquals(pCollection.getDescription(testBarcode);
 	}
 	
 	// Tests if item collection properly returns null, when instantiating a null item
 	@Test
 	public void nullItem() {
-		ItemsCollection iCollection = new ItemsCollection(null, null);
+		ItemsCollection iCollection = new ItemsCollection(null, 1.0);
+		iCollection.weightInGrams = 0.0;
 		Assert.assertNull(iCollection);
+		//Assert.assertNull(iCollection);
 	}
 	
 	// Test to determine if item collection returns exception for negative weight

commit 6ff9f21df45d5ef57da4a2b40e85ee030c619b82
Author: staytheknight <staytheknight@gmail.com>
Date:   Sun Mar 20 22:07:43 2022 -0600

    Moved methods from CheckoutTest to CustomerScanItem

diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 7d40bc4..4592961 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/bin/test/control/software/CustomerScanItemTest.class b/bin/test/control/software/CustomerScanItemTest.class
index 15de18d..8f26cfe 100644
Binary files a/bin/test/control/software/CustomerScanItemTest.class and b/bin/test/control/software/CustomerScanItemTest.class differ
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index 7ace7c8..2cc5460 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -14,63 +14,6 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 
 
 public class CheckoutTest {
-	Barcode testBarcode;
-	
-	// Generates dummy barcode;
-	@Before
-	public void barcodeSetup() {
-		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};		
-		Barcode testBarcode = new Barcode(n);
-	}
 
-	@Test
-	public void test() {
-		fail("Not yet implemented");
-	}
-	
-	// TODO : Products collection properly instantiates items.
-	// Not complete
-	@Test
-	public void test2() {
-		ProductsCollection pCollection = new ProductsCollection();
-		pCollection.initializeProducts();
-	}
-	
-	// Tests if item collection properly returns null, when instantiating a null item
-	@Test
-	public void nullItem() {
-		ItemsCollection iCollection = new ItemsCollection(null, null);
-		Assert.assertNull(iCollection);
-	}
-	
-	// Test to determine if item collection returns exception for negative weight
-	// TODO: Completely commented out as I could not get it to work properly
-	/*
-	@Test 
-	void negWeightItem() {
-
-		//ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
-		Assert.assertThrows(IllegalArgumentException.class, new ItemsCollection(testBarcode, -1.0));
-
-	}*/
-	
-	@Rule
-	public ExpectedException exception = ExpectedException.none();
-	
-	// Test to determine if item collection returns exception for negative weight
-	// TODO : attempt #2 - ECL Lemma not returning as covered
-	@Test
-	public void negWeightItem2() throws SimulationException {
-		exception.expect(SimulationException.class);
-		ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
-	}
-	
-	@Test
-	public void posWeightItem() {
-		double dummyWeight;
-		ItemsCollection iCollection = new ItemsCollection(testBarcode, 5.2);
-		dummyWeight = iCollection.getWeight();
-		Assert.assertEquals(5.2, dummyWeight, 0);
-	}
 
 }
diff --git a/src/test/control/software/CustomerScanItemTest.java b/src/test/control/software/CustomerScanItemTest.java
index 9750a85..b17313f 100644
--- a/src/test/control/software/CustomerScanItemTest.java
+++ b/src/test/control/software/CustomerScanItemTest.java
@@ -2,13 +2,74 @@ package test.control.software;
 
 import static org.junit.Assert.*;
 
+import org.control.software.ItemsCollection;
+import org.control.software.ProductsCollection;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.devices.SimulationException;
 
 public class CustomerScanItemTest {
+	Barcode testBarcode;
+	
+	// Generates dummy barcode;
+	@Before
+	public void barcodeSetup() {
+		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};		
+		Barcode testBarcode = new Barcode(n);
+	}
 
 	@Test
 	public void test() {
 		fail("Not yet implemented");
 	}
+	
+	// TODO : Products collection properly instantiates items.
+	// Not complete
+	@Test
+	public void test2() {
+		ProductsCollection pCollection = new ProductsCollection();
+		pCollection.initializeProducts();
+	}
+	
+	// Tests if item collection properly returns null, when instantiating a null item
+	@Test
+	public void nullItem() {
+		ItemsCollection iCollection = new ItemsCollection(null, null);
+		Assert.assertNull(iCollection);
+	}
+	
+	// Test to determine if item collection returns exception for negative weight
+	// TODO: Completely commented out as I could not get it to work properly
+	/*
+	@Test 
+	void negWeightItem() {
 
+		//ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
+		Assert.assertThrows(IllegalArgumentException.class, new ItemsCollection(testBarcode, -1.0));
+
+	}*/
+	
+	@Rule
+	public ExpectedException exception = ExpectedException.none();
+	
+	// Test to determine if item collection returns exception for negative weight
+	// TODO : attempt #2 - ECL Lemma not returning as covered
+	@Test
+	public void negWeightItem2() throws SimulationException {
+		exception.expect(SimulationException.class);
+		ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
+	}
+	
+	@Test
+	public void posWeightItem() {
+		double dummyWeight;
+		ItemsCollection iCollection = new ItemsCollection(testBarcode, 5.2);
+		dummyWeight = iCollection.getWeight();
+		Assert.assertEquals(5.2, dummyWeight, 0);
+	}
 }

commit 758f9f02bc68d110e3f85d2fb96f27f3ef091c37
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:06:02 2022 -0600

    fkalsd;fj

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index e4d5951..355ff85 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 54cd238..7d40bc4 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 032a0de..f6ee08d 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
+	public ItemsCollection(Barcode barcode, Double weightInGrams) {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));

commit 408744613cd30e83df547414f5737f39ab9220cc
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:04:54 2022 -0600

    changed visibility of itemscollection

diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 7d40bc4..54cd238 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ

commit 44260241924b815a6728d5067e65b988fb9a53df
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 22:01:20 2022 -0600

    updated observers

diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 355ff85..e4d5951 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/src/org/control/software/CheckoutController.java b/src/org/control/software/CheckoutController.java
new file mode 100644
index 0000000..132b078
--- /dev/null
+++ b/src/org/control/software/CheckoutController.java
@@ -0,0 +1,20 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+
+public class CheckoutController {
+	
+	BanknoteValidatorControlObserver banknoteValidator = new BanknoteValidatorControlObserver();
+	CoinValidatorControlObserver coinValidator = new CoinValidatorControlObserver();
+	ReceiptPrinterControlObserver receiptPrinter = new ReceiptPrinterControlObserver();
+	private SelfCheckoutStation checkoutStation;
+	
+	public void checkout() {
+		
+		int checkoutTotal = banknoteValidator.totalValue + coinValidator.totalValue;
+		checkoutStation.printer.print('C');
+		
+	}
+	
+
+}
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index f6ee08d..032a0de 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	public ItemsCollection(Barcode barcode, Double weightInGrams) {
+	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
diff --git a/src/org/control/software/ReceiptPrinterControlObserver.java b/src/org/control/software/ReceiptPrinterControlObserver.java
new file mode 100644
index 0000000..81d4121
--- /dev/null
+++ b/src/org/control/software/ReceiptPrinterControlObserver.java
@@ -0,0 +1,70 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public class ReceiptPrinterControlObserver implements ReceiptPrinterObserver {
+	
+	private SelfCheckoutStation checkoutStation;
+	boolean outOfPaper;
+	boolean outOfInk;
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.printer.enable();
+		
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.printer.disable();
+		
+	}
+	
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void outOfPaper(ReceiptPrinter printer) {
+		outOfPaper = true;
+	}
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void outOfInk(ReceiptPrinter printer) {
+		outOfInk = true;
+	}
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void paperAdded(ReceiptPrinter printer) {
+		checkoutStation.printer.addInk(checkoutStation.printer.MAXIMUM_PAPER);
+	}
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	public void inkAdded(ReceiptPrinter printer) {
+		checkoutStation.printer.addInk(checkoutStation.printer.MAXIMUM_INK);
+	}
+}
+

commit 3a56a3763a5d72b08b869e53cac79f2e6b0452f5
Author: lime39 <bobj32258@gmail.com>
Date:   Sun Mar 20 21:46:18 2022 -0600

    Corrected negWeightItem2 and posWeightitem.

diff --git a/bin/.gitignore b/bin/.gitignore
index 19796a1..f96f4d0 100644
--- a/bin/.gitignore
+++ b/bin/.gitignore
@@ -1,2 +1,2 @@
-/test/
 /org/
+/test/
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 36239d9..7d40bc4 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index f909704..7ace7c8 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -10,6 +10,7 @@ import org.junit.Rule;
 import org.junit.rules.ExpectedException;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.devices.SimulationException;
 
 
 public class CheckoutTest {
@@ -59,11 +60,8 @@ public class CheckoutTest {
 	// Test to determine if item collection returns exception for negative weight
 	// TODO : attempt #2 - ECL Lemma not returning as covered
 	@Test
-	public void negWeightItem2() {
-		
-		exception.expect(IllegalArgumentException.class);
-		exception.expectMessage("The weight has to be positive.");
-		
+	public void negWeightItem2() throws SimulationException {
+		exception.expect(SimulationException.class);
 		ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
 	}
 	
@@ -72,7 +70,7 @@ public class CheckoutTest {
 		double dummyWeight;
 		ItemsCollection iCollection = new ItemsCollection(testBarcode, 5.2);
 		dummyWeight = iCollection.getWeight();
-		Assert.assertEquals(5.2, dummyWeight);
+		Assert.assertEquals(5.2, dummyWeight, 0);
 	}
 
 }

commit c133187835fea4b16b4c8595cb12ac3ff7e0c826
Author: staytheknight <staytheknight@gmail.com>
Date:   Sun Mar 20 20:22:33 2022 -0600

    Added a few basic test functions

diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..19796a1
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1,2 @@
+/test/
+/org/
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index e4d5951..355ff85 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/test/control/software/BanknotePaymentTest.class b/bin/test/control/software/BanknotePaymentTest.class
index 797165b..9221364 100644
Binary files a/bin/test/control/software/BanknotePaymentTest.class and b/bin/test/control/software/BanknotePaymentTest.class differ
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
index 3d287d0..36239d9 100644
Binary files a/bin/test/control/software/CheckoutTest.class and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 032a0de..f6ee08d 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -21,7 +21,7 @@ public class ItemsCollection extends Item {
 	 * @throws SimulationException
 	 *             If the weight is &le;0.
 	 */
-	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
+	public ItemsCollection(Barcode barcode, Double weightInGrams) {
 		super(weightInGrams);
 		if(weightInGrams <= 0.0)
 			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
diff --git a/src/test/control/software/BanknotePaymentTest.java b/src/test/control/software/BanknotePaymentTest.java
index ded2d0c..d25d261 100644
--- a/src/test/control/software/BanknotePaymentTest.java
+++ b/src/test/control/software/BanknotePaymentTest.java
@@ -1,6 +1,5 @@
 package test.control.software;
 
-import static org.junit.Assert.*;
 import java.util.Currency;
 import org.control.software.BanknoteValidatorControlObserver;
 import org.junit.Assert;
@@ -10,6 +9,7 @@ import org.lsmr.selfcheckout.devices.BanknoteValidator;
 
 public class BanknotePaymentTest {
 	
+
 	@Test
 	public void validBanknoteDetecedTest() {
 		
@@ -21,5 +21,17 @@ public class BanknotePaymentTest {
 		Assert.assertEquals(validatorObserver.totalValue, 100);
 		
 	}
+	
+	
+	// Test to toggle the observer on and off
+	// TODO : currently not working or complete.
+	@Test
+	public void validBVCOToggle() {
+		
+		BanknoteValidatorControlObserver validatorObserver = new BanknoteValidatorControlObserver();
+		//validatorObserver.enabled(null);
+		//Assert.assertTrue();
+		
+	}
 
 }
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
index e73693c..f909704 100644
--- a/src/test/control/software/CheckoutTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -1,14 +1,78 @@
 package test.control.software;
 
 import static org.junit.Assert.*;
-
+import org.control.software.ProductsCollection;
+import org.control.software.ItemsCollection;
+import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
+import org.junit.Rule;
+import org.junit.rules.ExpectedException;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Numeral;
+
 
 public class CheckoutTest {
+	Barcode testBarcode;
+	
+	// Generates dummy barcode;
+	@Before
+	public void barcodeSetup() {
+		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};		
+		Barcode testBarcode = new Barcode(n);
+	}
 
 	@Test
 	public void test() {
 		fail("Not yet implemented");
 	}
+	
+	// TODO : Products collection properly instantiates items.
+	// Not complete
+	@Test
+	public void test2() {
+		ProductsCollection pCollection = new ProductsCollection();
+		pCollection.initializeProducts();
+	}
+	
+	// Tests if item collection properly returns null, when instantiating a null item
+	@Test
+	public void nullItem() {
+		ItemsCollection iCollection = new ItemsCollection(null, null);
+		Assert.assertNull(iCollection);
+	}
+	
+	// Test to determine if item collection returns exception for negative weight
+	// TODO: Completely commented out as I could not get it to work properly
+	/*
+	@Test 
+	void negWeightItem() {
+
+		//ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
+		Assert.assertThrows(IllegalArgumentException.class, new ItemsCollection(testBarcode, -1.0));
+
+	}*/
+	
+	@Rule
+	public ExpectedException exception = ExpectedException.none();
+	
+	// Test to determine if item collection returns exception for negative weight
+	// TODO : attempt #2 - ECL Lemma not returning as covered
+	@Test
+	public void negWeightItem2() {
+		
+		exception.expect(IllegalArgumentException.class);
+		exception.expectMessage("The weight has to be positive.");
+		
+		ItemsCollection iCollection = new ItemsCollection(testBarcode, -1.0);
+	}
+	
+	@Test
+	public void posWeightItem() {
+		double dummyWeight;
+		ItemsCollection iCollection = new ItemsCollection(testBarcode, 5.2);
+		dummyWeight = iCollection.getWeight();
+		Assert.assertEquals(5.2, dummyWeight);
+	}
 
 }

commit e6fc9d2154c10caf3888c116ccc1a9d80924a562
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 15:37:10 2022 -0600

    first test case start

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index bf2cbb9..138b7e2 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
index 89c1818..1029cfb 100644
Binary files a/bin/org/control/software/BanknoteValidatorControlObserver.class and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 36c2317..0166df9 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/test/control/software/BanknotePaymentTest.class b/bin/test/control/software/BanknotePaymentTest.class
index 21c2156..797165b 100644
Binary files a/bin/test/control/software/BanknotePaymentTest.class and b/bin/test/control/software/BanknotePaymentTest.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index f5c889b..af6886c 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -15,9 +15,9 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
 	
 	private SelfCheckoutStation checkoutStation;
-	int totalBanknotes;
-	int totalValue;
-	int noteValue;
+	public int totalBanknotes;
+	public int totalValue;
+	public int noteValue;
 	Currency cad = Currency.getInstance("CAD");
 	
 	
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index 876f77a..25082a2 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -14,9 +14,9 @@ import org.lsmr.selfcheckout.devices.DisabledException;
 public class BanknoteValidatorControlObserver implements BanknoteValidatorObserver{
 	
 	private SelfCheckoutStation checkoutStation;
-	int totalBanknotes;
-	int totalValue;
-	int noteValue;
+	public int totalBanknotes;
+	public int totalValue;
+	public int noteValue;
 	Currency cad = Currency.getInstance("CAD");
 	
 	/**
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index f6cf6e0..b4ce98c 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -15,8 +15,8 @@ import org.lsmr.selfcheckout.devices.DisabledException;
  */
 public class CoinValidatorControlObserver implements CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
-	int totalCoins;
-	int totalValue;
+	public int totalCoins;
+	public int totalValue;
 	BigDecimal coinValue;
 
 	/**
diff --git a/src/test/control/software/BanknotePaymentTest.java b/src/test/control/software/BanknotePaymentTest.java
index 0f45492..ded2d0c 100644
--- a/src/test/control/software/BanknotePaymentTest.java
+++ b/src/test/control/software/BanknotePaymentTest.java
@@ -1,25 +1,24 @@
 package test.control.software;
 
 import static org.junit.Assert.*;
-
 import java.util.Currency;
-
-import org.control.software.BanknoteSlotControlObserver;
+import org.control.software.BanknoteValidatorControlObserver;
 import org.junit.Assert;
 import org.junit.Test;
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
 
-public class BanknotePaymentTest {
 
-	@Test
-	public void test() {
-		fail("Not yet implemented");
-	}
+public class BanknotePaymentTest {
 	
-	public void banknoteInserted() {
-		BanknoteSlotControlObserver observer = new BanknoteSlotControlObserver();
-		BanknoteSlot slot = new BanknoteSlot(true);
+	@Test
+	public void validBanknoteDetecedTest() {
+		
+		BanknoteValidatorControlObserver validatorObserver = new BanknoteValidatorControlObserver();
+		Currency cad = Currency.getInstance("CAD");
+		int banknotes[] = {25, 50, 100};
+		BanknoteValidator validator = new BanknoteValidator(cad, banknotes);
+		validatorObserver.validBanknoteDetected(validator, cad, 100);
+		Assert.assertEquals(validatorObserver.totalValue, 100);
 		
 	}
 

commit 249f473ba5cb0e055aaccb9c9f50c2a2d9e0cd1f
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 15:06:11 2022 -0600

    updated depdencies

diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
index 521f642..bf2cbb9 100644
Binary files a/bin/org/control/software/BanknoteSlotControlObserver.class and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
index 2d932b2..89c1818 100644
Binary files a/bin/org/control/software/BanknoteValidatorControlObserver.class and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
index 4480bd3..29ccd6d 100644
Binary files a/bin/org/control/software/CoinTrayControlObserver.class and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index e7bb060..36c2317 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/test/control/software/BanknotePaymentTest.class b/bin/test/control/software/BanknotePaymentTest.class
new file mode 100644
index 0000000..21c2156
Binary files /dev/null and b/bin/test/control/software/BanknotePaymentTest.class differ
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
new file mode 100644
index 0000000..3d287d0
Binary files /dev/null and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/bin/test/control/software/CoinPaymentTest.class b/bin/test/control/software/CoinPaymentTest.class
new file mode 100644
index 0000000..b0045e6
Binary files /dev/null and b/bin/test/control/software/CoinPaymentTest.class differ
diff --git a/bin/test/control/software/ControlSoftwareTest.class b/bin/test/control/software/ControlSoftwareTest.class
deleted file mode 100644
index e3a7412..0000000
Binary files a/bin/test/control/software/ControlSoftwareTest.class and /dev/null differ
diff --git a/bin/test/control/software/CustomerBagsItemTest.class b/bin/test/control/software/CustomerBagsItemTest.class
new file mode 100644
index 0000000..96415c8
Binary files /dev/null and b/bin/test/control/software/CustomerBagsItemTest.class differ
diff --git a/bin/test/control/software/CustomerScanItemTest.class b/bin/test/control/software/CustomerScanItemTest.class
new file mode 100644
index 0000000..15de18d
Binary files /dev/null and b/bin/test/control/software/CustomerScanItemTest.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
index eaf2003..f5c889b 100644
--- a/src/org/control/software/BanknoteSlotControlObserver.java
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -3,9 +3,7 @@ import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
 import java.util.Currency;
-
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.DisabledException;
@@ -91,7 +89,9 @@ public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
 	 *            The device on which the event occurred.
 	 */
 	public void banknoteRemoved(BanknoteSlot slot){
+		
 		slot.removeDanglingBanknote();
+		totalValue -= noteValue;
 		totalBanknotes--;
 		
 	}
diff --git a/src/org/control/software/BanknoteValidatorControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
index 00890f3..876f77a 100644
--- a/src/org/control/software/BanknoteValidatorControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -60,11 +60,11 @@ public class BanknoteValidatorControlObserver implements BanknoteValidatorObserv
 		try {
 			validator.accept(banknote);
 			isValid = true;
+			totalBanknotes++;
+			totalValue += value;
 		} catch (DisabledException e) {
 			e.printStackTrace();
 		}
-		totalBanknotes++;
-		totalValue += value;
 		
 	}
 	
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
index dce5107..b305b5e 100644
--- a/src/org/control/software/CoinTrayControlObserver.java
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -29,8 +29,6 @@ public class CoinTrayControlObserver implements CoinTrayObserver {
 	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.enable();
-		
-		
 	}
 
 	/**
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index 4de0cac..f6cf6e0 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -57,11 +57,11 @@ public class CoinValidatorControlObserver implements CoinValidatorObserver{
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
+			totalCoins++;
+			totalValue += coinValue.intValue();
 		} catch (DisabledException e) {
 			e.printStackTrace();
 		}
-		totalCoins++;
-		totalValue += coinValue.intValue();
 	}
 	
 	/**
diff --git a/src/test/control/software/BanknotePaymentTest.java b/src/test/control/software/BanknotePaymentTest.java
new file mode 100644
index 0000000..0f45492
--- /dev/null
+++ b/src/test/control/software/BanknotePaymentTest.java
@@ -0,0 +1,26 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import java.util.Currency;
+
+import org.control.software.BanknoteSlotControlObserver;
+import org.junit.Assert;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+public class BanknotePaymentTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+	
+	public void banknoteInserted() {
+		BanknoteSlotControlObserver observer = new BanknoteSlotControlObserver();
+		BanknoteSlot slot = new BanknoteSlot(true);
+		
+	}
+
+}
diff --git a/src/test/control/software/ControlSoftwareTest.java b/src/test/control/software/CheckoutTest.java
similarity index 81%
rename from src/test/control/software/ControlSoftwareTest.java
rename to src/test/control/software/CheckoutTest.java
index 3fb9986..e73693c 100644
--- a/src/test/control/software/ControlSoftwareTest.java
+++ b/src/test/control/software/CheckoutTest.java
@@ -4,7 +4,7 @@ import static org.junit.Assert.*;
 
 import org.junit.Test;
 
-public class ControlSoftwareTest {
+public class CheckoutTest {
 
 	@Test
 	public void test() {
diff --git a/src/test/control/software/CoinPaymentTest.java b/src/test/control/software/CoinPaymentTest.java
new file mode 100644
index 0000000..682f2e7
--- /dev/null
+++ b/src/test/control/software/CoinPaymentTest.java
@@ -0,0 +1,14 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class CoinPaymentTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}
diff --git a/src/test/control/software/CustomerBagsItemTest.java b/src/test/control/software/CustomerBagsItemTest.java
new file mode 100644
index 0000000..9cf6c8b
--- /dev/null
+++ b/src/test/control/software/CustomerBagsItemTest.java
@@ -0,0 +1,14 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class CustomerBagsItemTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}
diff --git a/src/test/control/software/CustomerScanItemTest.java b/src/test/control/software/CustomerScanItemTest.java
new file mode 100644
index 0000000..9750a85
--- /dev/null
+++ b/src/test/control/software/CustomerScanItemTest.java
@@ -0,0 +1,14 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class CustomerScanItemTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}

commit 3bf97c7db39f1bcac66eb6a058a4df94ed5b2493
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 20 14:25:36 2022 -0600

    updated control software

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
deleted file mode 100644
index 7ba4c95..0000000
Binary files a/bin/org/control/software/BanknoteControlObserver.class and /dev/null differ
diff --git a/bin/org/control/software/BanknoteSlotControlObserver.class b/bin/org/control/software/BanknoteSlotControlObserver.class
new file mode 100644
index 0000000..521f642
Binary files /dev/null and b/bin/org/control/software/BanknoteSlotControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteStorageUnitControlObserver.class b/bin/org/control/software/BanknoteStorageUnitControlObserver.class
new file mode 100644
index 0000000..65c6dcb
Binary files /dev/null and b/bin/org/control/software/BanknoteStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/BanknoteValidatorControlObserver.class b/bin/org/control/software/BanknoteValidatorControlObserver.class
new file mode 100644
index 0000000..2d932b2
Binary files /dev/null and b/bin/org/control/software/BanknoteValidatorControlObserver.class differ
diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
index d8de35f..55baa25 100644
Binary files a/bin/org/control/software/BarcodeScannerControlObserver.class and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
index 6337585..476aafc 100644
Binary files a/bin/org/control/software/CoinSlotControlObserver.class and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinStorageUnitControlObserver.class b/bin/org/control/software/CoinStorageUnitControlObserver.class
index 01f2591..13729ee 100644
Binary files a/bin/org/control/software/CoinStorageUnitControlObserver.class and b/bin/org/control/software/CoinStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
index f0cf11b..4480bd3 100644
Binary files a/bin/org/control/software/CoinTrayControlObserver.class and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
index 79e621d..e7bb060 100644
Binary files a/bin/org/control/software/CoinValidatorControlObserver.class and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
index 06b7955..e4d5951 100644
Binary files a/bin/org/control/software/ItemsCollection.class and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
index 3c6ea64..d799f1e 100644
Binary files a/bin/org/control/software/ProductsCollection.class and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/src/org/control/software/BanknoteSlotControlObserver.java b/src/org/control/software/BanknoteSlotControlObserver.java
new file mode 100644
index 0000000..eaf2003
--- /dev/null
+++ b/src/org/control/software/BanknoteSlotControlObserver.java
@@ -0,0 +1,98 @@
+package org.control.software;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public class BanknoteSlotControlObserver implements BanknoteSlotObserver {
+	
+	private SelfCheckoutStation checkoutStation;
+	int totalBanknotes;
+	int totalValue;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
+	
+	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.enable();
+		checkoutStation.banknoteOutput.enable();
+	
+	}
+
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.disable();
+		checkoutStation.banknoteOutput.disable();
+		
+	}
+	
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	public void banknoteInserted(BanknoteSlot slot){
+		
+		Banknote banknote = new Banknote(cad, noteValue);
+		try {
+			slot.accept(banknote);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
+		
+	}
+	
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	public void banknoteEjected(BanknoteSlot slot){
+		
+		Banknote bankNote = new Banknote(cad, noteValue);
+		try {
+			slot.emit(bankNote);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
+	}
+	
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	public void banknoteRemoved(BanknoteSlot slot){
+		slot.removeDanglingBanknote();
+		totalBanknotes--;
+		
+	}
+}
diff --git a/src/org/control/software/BanknoteStorageUnitControlObserver.java b/src/org/control/software/BanknoteStorageUnitControlObserver.java
new file mode 100644
index 0000000..a9ffc0e
--- /dev/null
+++ b/src/org/control/software/BanknoteStorageUnitControlObserver.java
@@ -0,0 +1,110 @@
+package org.control.software;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public class BanknoteStorageUnitControlObserver implements BanknoteStorageUnitObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	boolean banknotesFull;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
+	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteStorage.enable();
+	}
+
+	
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteStorage.disable();
+		
+	}
+
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	public void banknotesFull(BanknoteStorageUnit unit) {
+		
+		if(unit.getBanknoteCount() > unit.getCapacity()) {
+			banknotesFull = true;
+		}
+		
+	}
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	public void banknoteAdded(BanknoteStorageUnit unit) {
+		
+		Banknote banknote = new Banknote(cad, noteValue);
+		try {
+			unit.accept(banknote);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
+		
+	}
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	public void banknotesLoaded(BanknoteStorageUnit unit) {
+		
+		Banknote banknote = new Banknote(cad, noteValue);
+		try {
+			unit.load(banknote);
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+		
+	}
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	public void banknotesUnloaded(BanknoteStorageUnit unit) {
+		
+		unit.unload();
+		
+	}
+
+}
diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteValidatorControlObserver.java
similarity index 50%
rename from src/org/control/software/BanknoteControlObserver.java
rename to src/org/control/software/BanknoteValidatorControlObserver.java
index e016c05..00890f3 100644
--- a/src/org/control/software/BanknoteControlObserver.java
+++ b/src/org/control/software/BanknoteValidatorControlObserver.java
@@ -2,56 +2,65 @@ package org.control.software;
 import java.util.Currency;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
-public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public class BanknoteValidatorControlObserver implements BanknoteValidatorObserver{
+	
 	private SelfCheckoutStation checkoutStation;
 	int totalBanknotes;
 	int totalValue;
+	int noteValue;
+	Currency cad = Currency.getInstance("CAD");
 	
-	
+	/**
+	 * Enables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
-		checkoutStation.banknoteInput.enable();
-		checkoutStation.banknoteOutput.enable();
 		checkoutStation.banknoteValidator.enable();
 	
 	}
 
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
-		checkoutStation.banknoteInput.disable();
-		checkoutStation.banknoteOutput.disable();
 		checkoutStation.banknoteValidator.disable();
 		
 	}
 	
-	public void banknoteInserted(BanknoteSlot slot){
-		
-	}
-	
-	public void banknoteEjected(BanknoteSlot slot){
-		
-	}
-	
-	public void banknoteRemoved(BanknoteSlot slot){
-		slot.removeDanglingBanknote();
-		totalBanknotes--;
-		
-	}
-	
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 		Banknote banknote = new Banknote(currency, value);
+		boolean isValid = false;
 		try {
 			validator.accept(banknote);
+			isValid = true;
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		totalBanknotes++;
@@ -59,7 +68,23 @@ public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteVa
 		
 	}
 	
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
 	public void invalidBanknoteDetected(BanknoteValidator validator) {
 		
+		Banknote banknote = new Banknote(cad, noteValue);
+		boolean isValid = false;
+		try {
+			validator.accept(banknote);
+			isValid = true;
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
 	}
 }
\ No newline at end of file
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
index e25c137..8710f92 100644
--- a/src/org/control/software/BarcodeScannerControlObserver.java
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -3,36 +3,54 @@ package org.control.software;
 import java.math.BigDecimal;
 
 import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
 
+/**
+ * Observes events emanating from a barcode scanner.
+ */
 public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
 	
 	private SelfCheckoutStation checkoutStation;
 	BigDecimal totalValue = new BigDecimal(0.0);
 	int totalItems;
-	//
-	@Override
+
+	/**
+	 * Enables barcode devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.scanner.enable();
 		
 	}
 
-	@Override
+	/**
+	 * Disables banknote devices.
+	 * 
+	 * @param device
+	 * 				AbstractDevice of any type
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.scanner.disable();
 		
 	}
 
-	@Override
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
 	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
 		
 		ProductsCollection products = new ProductsCollection();
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
index a6a2075..905e268 100644
--- a/src/org/control/software/CoinSlotControlObserver.java
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -8,18 +8,38 @@ import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinSlot;
+import org.lsmr.selfcheckout.devices.DisabledException;
+
+/**
+ * Observes events emanating from a coin slot.
+ *
+ */
 
 public class CoinSlotControlObserver implements CoinSlotObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
 	int totalAmount;
+	BigDecimal coinValue;
 	
 	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinSlot.enable();
 	
 	}
+	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
@@ -27,7 +47,20 @@ public class CoinSlotControlObserver implements CoinSlotObserver{
 		
 	}
 	
-	public void coinInserted(CoinSlot slot){
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	public void coinInserted(CoinSlot slot) {
+		
+		Coin coin = new Coin(coinValue);
+		try {
+			slot.accept(coin);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
 		
 	}
 }
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
index fae8082..c0d5b11 100644
--- a/src/org/control/software/CoinStorageUnitControlObserver.java
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -1,46 +1,107 @@
 package org.control.software;
 
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
 
+/**
+ * Observes events emanating from a coin storage unit.
+ *
+ */
 public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
 
 	private SelfCheckoutStation checkoutStation;
+	boolean coinsFull;
+	BigDecimal coinValue;
 	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinStorage.enable();
 		
 	}
 
-	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinStorage.disable();
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsFull(CoinStorageUnit unit) {
 		
+		if (unit.getCoinCount() > unit.getCapacity()) {
+			coinsFull = true;
+		}
 		
 	}
 
-	
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinAdded(CoinStorageUnit unit) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			unit.accept(coin);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
 		
 	}
 
-	
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsLoaded(CoinStorageUnit unit) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			unit.load(coin);
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+		
 	}
 
-	
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
 	public void coinsUnloaded(CoinStorageUnit unit) {
 		
+		unit.unload();
 		
 	}
 
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
index 19b8254..dce5107 100644
--- a/src/org/control/software/CoinTrayControlObserver.java
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -1,28 +1,63 @@
 package org.control.software;
 
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 
+/**
+ * Observes events emanating from a coin tray. 
+ * 
+ */
+
 public class CoinTrayControlObserver implements CoinTrayObserver {
 
 	private SelfCheckoutStation checkoutStation;
+	BigDecimal coinValue;
+	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.enable();
 		
 		
 	}
 
-	
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		checkoutStation.coinTray.disable();
 		
 	}
 
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
 	public void coinAdded(CoinTray tray) {
 		
+		Coin coin = new Coin(coinValue);
+		try {
+			tray.accept(coin);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}	
 		
 	}
 
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
index 4980c4f..4de0cac 100644
--- a/src/org/control/software/CoinValidatorControlObserver.java
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -10,46 +10,74 @@ import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.devices.CoinValidator;
 import org.lsmr.selfcheckout.devices.DisabledException;
 
+/**
+ * Observes events emanating from a coin validator.
+ */
 public class CoinValidatorControlObserver implements CoinValidatorObserver{
 	private SelfCheckoutStation checkoutStation;
 	int totalCoins;
 	int totalValue;
 	BigDecimal coinValue;
 
-	
+	/**
+	 * Enables the Abstract device.
+	 * @param device
+	 * 				The specified device to enable.
+	 * 		
+	 */
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinValidator.enable();
 	
 	}
 
+	/**
+	 * Disables the Abstract device.
+	 * @param device
+	 * 				The specified device to disable.
+	 * 		
+	 */
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 		
 		checkoutStation.coinValidator.disable();
 		
 	}
 	
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
 	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
 		coinValue = value;
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 		totalCoins++;
 		totalValue += coinValue.intValue();
 	}
 	
-	@Override
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	
 	public void invalidCoinDetected(CoinValidator validator) {
 		boolean isValid = false;
 		Coin coin = new Coin(coinValue);
 		try {
 			validator.accept(coin);
 		} catch (DisabledException e) {
-			// TODO Auto-generated catch block
 			isValid = true;
 			e.printStackTrace();
 		}
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
index 313e3bb..032a0de 100644
--- a/src/org/control/software/ItemsCollection.java
+++ b/src/org/control/software/ItemsCollection.java
@@ -2,7 +2,6 @@ package org.control.software;
 
 import java.util.HashMap;
 import java.util.Map;
-
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.SimulationException;
@@ -39,7 +38,5 @@ public class ItemsCollection extends Item {
 	public double getWeight() {
 		return weightInGrams;
 	}
-	
-	
 
 }
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
index daa3cb4..af69e3d 100644
--- a/src/org/control/software/ProductsCollection.java
+++ b/src/org/control/software/ProductsCollection.java
@@ -10,6 +10,10 @@ import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 
 
+/**
+ * Simulates a products database.
+ *
+ */
 public class ProductsCollection {
 	
 	Map<Barcode, String> barcodesMap = new HashMap<Barcode, String>();
@@ -20,10 +24,17 @@ public class ProductsCollection {
 	Barcode milkBarcode;
 	Barcode riceBarcode;
 	
+	/**
+	 * Constructor that initializes products collection.
+	 */
 	public ProductsCollection() {
 		this.initializeProducts();
 	}
 	
+	
+	/**
+	 * Initializes products with barcodes, prices, and descriptions.
+	 */
 	public void initializeProducts() {
 		
 		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
@@ -45,12 +56,28 @@ public class ProductsCollection {
 		
 	}
 	
+	
+	/**
+	 * Gets a set of products and their barcodes.
+	 * 
+	 * @return barcodesMap set
+	 */
 	public Set<Entry<Barcode, String>> getProducts() {
 		
 		return barcodesMap.entrySet();
 		
 	}
 	
+	
+	/**
+	 * Gets price for a specified product.
+	 * 
+	 * @param barcode
+	 * 				Product barcode.
+	 * 
+	 * @return price
+	 * 				Price of product.
+	 */
 	public BigDecimal getPrice(Barcode barcode) {
 		
 		BigDecimal price = new BigDecimal("0.0");
@@ -63,6 +90,15 @@ public class ProductsCollection {
 		
 	}
 	
+	/**
+	 * Gets description for a specified product.
+	 * 
+	 * @param barcode
+	 * 				Product barcode.
+	 * 
+	 * @return description
+	 * 				Description of product.
+	 */
 	public String getDescription(Barcode barcode) {
 		
 		String description = "";
@@ -75,6 +111,12 @@ public class ProductsCollection {
 		
 	}
 	
+	/**
+	 * Gets all barcodes.
+	 * 
+	 * @return barcodesMap keys
+	 * 				All barcodes.
+	 */
 	public Set<Barcode> getBarcodes() {
 		return barcodesMap.keySet();
 	}

commit 7ce1db88494996c47d72a72c457b44b1585576a3
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sat Mar 19 17:44:47 2022 -0600

    fixed EVERYTHING

diff --git a/bin/org/control/software/BanknoteControlObserver.class b/bin/org/control/software/BanknoteControlObserver.class
new file mode 100644
index 0000000..7ba4c95
Binary files /dev/null and b/bin/org/control/software/BanknoteControlObserver.class differ
diff --git a/bin/org/control/software/BarcodeScannerControlObserver.class b/bin/org/control/software/BarcodeScannerControlObserver.class
new file mode 100644
index 0000000..d8de35f
Binary files /dev/null and b/bin/org/control/software/BarcodeScannerControlObserver.class differ
diff --git a/bin/org/control/software/CoinSlotControlObserver.class b/bin/org/control/software/CoinSlotControlObserver.class
new file mode 100644
index 0000000..6337585
Binary files /dev/null and b/bin/org/control/software/CoinSlotControlObserver.class differ
diff --git a/bin/org/control/software/CoinStorageUnitControlObserver.class b/bin/org/control/software/CoinStorageUnitControlObserver.class
new file mode 100644
index 0000000..01f2591
Binary files /dev/null and b/bin/org/control/software/CoinStorageUnitControlObserver.class differ
diff --git a/bin/org/control/software/CoinTrayControlObserver.class b/bin/org/control/software/CoinTrayControlObserver.class
new file mode 100644
index 0000000..f0cf11b
Binary files /dev/null and b/bin/org/control/software/CoinTrayControlObserver.class differ
diff --git a/bin/org/control/software/CoinValidatorControlObserver.class b/bin/org/control/software/CoinValidatorControlObserver.class
new file mode 100644
index 0000000..79e621d
Binary files /dev/null and b/bin/org/control/software/CoinValidatorControlObserver.class differ
diff --git a/bin/org/control/software/ItemsCollection.class b/bin/org/control/software/ItemsCollection.class
new file mode 100644
index 0000000..06b7955
Binary files /dev/null and b/bin/org/control/software/ItemsCollection.class differ
diff --git a/bin/org/control/software/ProductsCollection.class b/bin/org/control/software/ProductsCollection.class
new file mode 100644
index 0000000..3c6ea64
Binary files /dev/null and b/bin/org/control/software/ProductsCollection.class differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..f9137b3
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..1d775b9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..7663e5e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..5a71e46
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..43f9377
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..7e1201e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..6904466
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..7237b6a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..bf40f20
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..ec4b4c9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..07b0272
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..e9eef08
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..8596af8
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..188164a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..d20e45a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..40aa0f6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..e16042d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..33ab495
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..7eab7e1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..cde5cd4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..336f746
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..fb63130
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..5392983
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..4b2403f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..93860be
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..0cd6656
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..070c326
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..df34fc7
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..5c6a94f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..98c1447
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..ad3bd02
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..54ef20f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6e7e3b6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..8035612
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..047e5cb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..3795ab6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..6192fe8
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..d7cd1a2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..c8ad9fc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..15c5f48
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..dfffc3d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..b8195c5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..0667693
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..49acecf
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..34b8983
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..b9b098f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..776d67c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..c1c109d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..de7e42b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..63bd051
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..f9ad107
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..0cc44a6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..1b1f35b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..1c82e3c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..1c65181
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..7cfb5fa
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..fc59019
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..06ab7f4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..30d2169
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..7db0944
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..cbf4fa5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..6fa3791
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..8fa7145
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
deleted file mode 100644
index 56d4b49..0000000
Binary files a/bin/test/control/software/CheckoutTest.class and /dev/null differ
diff --git a/bin/test/control/software/ControlSoftwareTest.class b/bin/test/control/software/ControlSoftwareTest.class
new file mode 100644
index 0000000..e3a7412
Binary files /dev/null and b/bin/test/control/software/ControlSoftwareTest.class differ
diff --git a/bin/test/control/software/PaymentTest.class b/bin/test/control/software/PaymentTest.class
deleted file mode 100644
index dce0bbf..0000000
Binary files a/bin/test/control/software/PaymentTest.class and /dev/null differ
diff --git a/bin/test/control/software/ScanTest.class b/bin/test/control/software/ScanTest.class
deleted file mode 100644
index 9d9541a..0000000
Binary files a/bin/test/control/software/ScanTest.class and /dev/null differ
diff --git a/src/org/control/software/BanknoteControlObserver.java b/src/org/control/software/BanknoteControlObserver.java
new file mode 100644
index 0000000..e016c05
--- /dev/null
+++ b/src/org/control/software/BanknoteControlObserver.java
@@ -0,0 +1,65 @@
+package org.control.software;
+import java.util.Currency;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
+
+public class BanknoteControlObserver implements BanknoteSlotObserver, BanknoteValidatorObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalBanknotes;
+	int totalValue;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.enable();
+		checkoutStation.banknoteOutput.enable();
+		checkoutStation.banknoteValidator.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.banknoteInput.disable();
+		checkoutStation.banknoteOutput.disable();
+		checkoutStation.banknoteValidator.disable();
+		
+	}
+	
+	public void banknoteInserted(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteEjected(BanknoteSlot slot){
+		
+	}
+	
+	public void banknoteRemoved(BanknoteSlot slot){
+		slot.removeDanglingBanknote();
+		totalBanknotes--;
+		
+	}
+	
+	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		Banknote banknote = new Banknote(currency, value);
+		try {
+			validator.accept(banknote);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		totalBanknotes++;
+		totalValue += value;
+		
+	}
+	
+	public void invalidBanknoteDetected(BanknoteValidator validator) {
+		
+	}
+}
\ No newline at end of file
diff --git a/src/org/control/software/BarcodeScannerControlObserver.java b/src/org/control/software/BarcodeScannerControlObserver.java
new file mode 100644
index 0000000..e25c137
--- /dev/null
+++ b/src/org/control/software/BarcodeScannerControlObserver.java
@@ -0,0 +1,47 @@
+package org.control.software;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+
+public class BarcodeScannerControlObserver implements BarcodeScannerObserver {
+	
+	private SelfCheckoutStation checkoutStation;
+	BigDecimal totalValue = new BigDecimal(0.0);
+	int totalItems;
+	//
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.scanner.enable();
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.scanner.disable();
+		
+	}
+
+	@Override
+	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
+		
+		ProductsCollection products = new ProductsCollection();
+		BigDecimal price = products.getPrice(barcode);
+		Item item = products.itemsMap.get(barcode);
+		barcodeScanner.scan(item);
+		totalItems++;
+		totalValue = totalValue.add(price);
+		
+	}
+
+}
diff --git a/src/org/control/software/CoinSlotControlObserver.java b/src/org/control/software/CoinSlotControlObserver.java
new file mode 100644
index 0000000..a6a2075
--- /dev/null
+++ b/src/org/control/software/CoinSlotControlObserver.java
@@ -0,0 +1,33 @@
+package org.control.software;
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+public class CoinSlotControlObserver implements CoinSlotObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	int totalAmount;
+	
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinSlot.disable();
+		
+	}
+	
+	public void coinInserted(CoinSlot slot){
+		
+	}
+}
diff --git a/src/org/control/software/CoinStorageUnitControlObserver.java b/src/org/control/software/CoinStorageUnitControlObserver.java
new file mode 100644
index 0000000..fae8082
--- /dev/null
+++ b/src/org/control/software/CoinStorageUnitControlObserver.java
@@ -0,0 +1,47 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+public class CoinStorageUnitControlObserver implements CoinStorageUnitObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinStorage.enable();
+		
+	}
+
+	
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinStorage.disable();
+		
+	}
+
+	
+	public void coinsFull(CoinStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void coinAdded(CoinStorageUnit unit) {
+		
+		
+	}
+
+	
+	public void coinsLoaded(CoinStorageUnit unit) {
+		
+	}
+
+	
+	public void coinsUnloaded(CoinStorageUnit unit) {
+		
+		
+	}
+
+}
diff --git a/src/org/control/software/CoinTrayControlObserver.java b/src/org/control/software/CoinTrayControlObserver.java
new file mode 100644
index 0000000..19b8254
--- /dev/null
+++ b/src/org/control/software/CoinTrayControlObserver.java
@@ -0,0 +1,29 @@
+package org.control.software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+public class CoinTrayControlObserver implements CoinTrayObserver {
+
+	private SelfCheckoutStation checkoutStation;
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinTray.enable();
+		
+		
+	}
+
+	
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		checkoutStation.coinTray.disable();
+		
+	}
+
+	public void coinAdded(CoinTray tray) {
+		
+		
+	}
+
+}
diff --git a/src/org/control/software/CoinValidatorControlObserver.java b/src/org/control/software/CoinValidatorControlObserver.java
new file mode 100644
index 0000000..4980c4f
--- /dev/null
+++ b/src/org/control/software/CoinValidatorControlObserver.java
@@ -0,0 +1,58 @@
+package org.control.software;
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
+
+public class CoinValidatorControlObserver implements CoinValidatorObserver{
+	private SelfCheckoutStation checkoutStation;
+	int totalCoins;
+	int totalValue;
+	BigDecimal coinValue;
+
+	
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinValidator.enable();
+	
+	}
+
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		
+		checkoutStation.coinValidator.disable();
+		
+	}
+	
+	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+		coinValue = value;
+		Coin coin = new Coin(coinValue);
+		try {
+			validator.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		totalCoins++;
+		totalValue += coinValue.intValue();
+	}
+	
+	@Override
+	public void invalidCoinDetected(CoinValidator validator) {
+		boolean isValid = false;
+		Coin coin = new Coin(coinValue);
+		try {
+			validator.accept(coin);
+		} catch (DisabledException e) {
+			// TODO Auto-generated catch block
+			isValid = true;
+			e.printStackTrace();
+		}
+		
+	}
+}
\ No newline at end of file
diff --git a/src/org/control/software/ItemsCollection.java b/src/org/control/software/ItemsCollection.java
new file mode 100644
index 0000000..313e3bb
--- /dev/null
+++ b/src/org/control/software/ItemsCollection.java
@@ -0,0 +1,45 @@
+package org.control.software;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+
+public class ItemsCollection extends Item {
+	
+	double weightInGrams;
+	
+	Map<Barcode, Double> weightsMap = new HashMap<Barcode, Double>();
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected ItemsCollection(Barcode barcode, Double weightInGrams) {
+		super(weightInGrams);
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+		weightsMap.put(barcode, weightInGrams);
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+	
+	
+
+}
diff --git a/src/org/control/software/ProductsCollection.java b/src/org/control/software/ProductsCollection.java
new file mode 100644
index 0000000..daa3cb4
--- /dev/null
+++ b/src/org/control/software/ProductsCollection.java
@@ -0,0 +1,82 @@
+package org.control.software;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+
+
+public class ProductsCollection {
+	
+	Map<Barcode, String> barcodesMap = new HashMap<Barcode, String>();
+	Map<Barcode, String> descriptionsMap = new HashMap<>();
+	Map<Barcode, BigDecimal> pricesMap = new HashMap<Barcode, BigDecimal>();
+	Map<Barcode, ItemsCollection> itemsMap = new HashMap<Barcode, ItemsCollection>();
+	
+	Barcode milkBarcode;
+	Barcode riceBarcode;
+	
+	public ProductsCollection() {
+		this.initializeProducts();
+	}
+	
+	public void initializeProducts() {
+		
+		Numeral[] n = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+		
+		milkBarcode = new Barcode(n);
+		riceBarcode = new Barcode(n);
+
+		barcodesMap.put(milkBarcode, "Carton of Milk");
+		barcodesMap.put(riceBarcode, "Bag of rice");
+		
+		pricesMap.put(milkBarcode, new BigDecimal("2.99"));
+		pricesMap.put(riceBarcode, new BigDecimal("4.99"));
+		
+		descriptionsMap.put(milkBarcode, "Drink");
+		descriptionsMap.put(riceBarcode, "Grains");
+		
+		itemsMap.put(milkBarcode, new ItemsCollection(milkBarcode, 1.00));
+		itemsMap.put(riceBarcode, new ItemsCollection(riceBarcode, 0.5));
+		
+	}
+	
+	public Set<Entry<Barcode, String>> getProducts() {
+		
+		return barcodesMap.entrySet();
+		
+	}
+	
+	public BigDecimal getPrice(Barcode barcode) {
+		
+		BigDecimal price = new BigDecimal("0.0");
+		
+		if(pricesMap.containsKey(barcode)) {
+			price = pricesMap.get(barcode);
+		}
+		
+		return price;
+		
+	}
+	
+	public String getDescription(Barcode barcode) {
+		
+		String description = "";
+		
+		if(descriptionsMap.containsKey(barcode)) {
+			description = descriptionsMap.get(barcode);
+		}
+		
+		return description;
+		
+	}
+	
+	public Set<Barcode> getBarcodes() {
+		return barcodesMap.keySet();
+	}
+
+}
diff --git a/src/org/lsmr/selfcheckout/Banknote.java b/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..f91d858
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Banknote.java
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/Barcode.java b/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b8e1f7c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Barcode.java
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/src/org/lsmr/selfcheckout/BarcodedItem.java b/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..fab9792
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BarcodedItem.java
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/BlockedCardException.java b/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..3b6416e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BlockedCardException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Card.java b/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..58da94a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Card.java
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/ChipFailureException.java b/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..00c7c18
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/ChipFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Coin.java b/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..ede38a9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Coin.java
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/IllegalDigitException.java b/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..22e6f63
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/IllegalDigitException.java
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/InvalidPINException.java b/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..7134225
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/InvalidPINException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Item.java b/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..24e2842
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Item.java
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..fc5396e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Numeral.java b/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..c53e6f7
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Numeral.java
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/PLUCodedItem.java b/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..e0985d0
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/PLUCodedItem.java
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/PriceLookupCode.java b/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..c860edc
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/PriceLookupCode.java
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/TapFailureException.java b/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..66ea14e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/TapFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..20cb12a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Acceptor.java b/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..d3890b1
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Acceptor.java
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..df4e37e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..e8f30e4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..d773a2b
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..fc32c76
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..7e926a5
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..433dc07
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CardReader.java b/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..6f54d0d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CardReader.java
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..838766e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..9cc3516
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..97d5929
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinTray.java b/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..3ee4da7
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinTray.java
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..f444162
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/DisabledException.java b/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..7fce25d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/DisabledException.java
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..f6c0b47
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Emitter.java b/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..e4942a1
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Emitter.java
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/src/org/lsmr/selfcheckout/devices/EmptyException.java b/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..f8564db
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/EmptyException.java
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..089d324
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..5fb3376
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/OverloadException.java b/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..7fcc01d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/OverloadException.java
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..e1c16e6
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..0356dd2
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
@@ -0,0 +1,257 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>one scanner;</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale scale;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner scanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		scanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		scale.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		scanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/SimulationException.java b/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..7001f20
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/SimulationException.java
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..888ab32
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..5faa152
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..08d8fcd
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..f690ec9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..d4087a5
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..d63191a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..e3945d0
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..173be6c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..2494e38
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..75900f2
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..4c6f974
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..5a67bb4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..7229824
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..dcbdb49
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..16e810f
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..d630fea
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..794b53a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.barcode = barcode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..ef28888
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/products/Product.java b/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..cd7ccb4
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/products/Product.java
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
deleted file mode 100644
index 83d8d77..0000000
--- a/src/test/control/software/CheckoutTest.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package test.control.software;
-
-import static org.junit.Assert.*;
-
-import org.control.software.Checkout;
-import org.junit.Test;
-
-public class CheckoutTest {
-	
-	Checkout c = new Checkout();
-
-	@Test
-	public void test() {
-		fail("Not yet implemented");
-	}
-
-}
diff --git a/src/test/control/software/PaymentTest.java b/src/test/control/software/ControlSoftwareTest.java
similarity index 81%
rename from src/test/control/software/PaymentTest.java
rename to src/test/control/software/ControlSoftwareTest.java
index eb6927b..3fb9986 100644
--- a/src/test/control/software/PaymentTest.java
+++ b/src/test/control/software/ControlSoftwareTest.java
@@ -4,7 +4,7 @@ import static org.junit.Assert.*;
 
 import org.junit.Test;
 
-public class PaymentTest {
+public class ControlSoftwareTest {
 
 	@Test
 	public void test() {
diff --git a/src/test/control/software/ScanTest.java b/src/test/control/software/ScanTest.java
deleted file mode 100644
index 64b6e7a..0000000
--- a/src/test/control/software/ScanTest.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package test.control.software;
-
-import static org.junit.Assert.*;
-
-import org.junit.Test;
-
-public class ScanTest {
-
-	@Test
-	public void test() {
-		fail("Not yet implemented");
-	}
-
-}

commit f26666e94303822138159408ae20a00aa10f26d1
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Sun Mar 13 17:27:40 2022 -0600

    fixed build path and added junit4

diff --git a/.classpath b/.classpath
index 7d3b4d8..0e04d81 100644
--- a/.classpath
+++ b/.classpath
@@ -6,5 +6,7 @@
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="src" path="/SCS - Software"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/bin/test/control/software/CheckoutTest.class b/bin/test/control/software/CheckoutTest.class
new file mode 100644
index 0000000..56d4b49
Binary files /dev/null and b/bin/test/control/software/CheckoutTest.class differ
diff --git a/bin/test/control/software/PaymentTest.class b/bin/test/control/software/PaymentTest.class
new file mode 100644
index 0000000..dce0bbf
Binary files /dev/null and b/bin/test/control/software/PaymentTest.class differ
diff --git a/bin/test/control/software/ScanTest.class b/bin/test/control/software/ScanTest.class
new file mode 100644
index 0000000..9d9541a
Binary files /dev/null and b/bin/test/control/software/ScanTest.class differ
diff --git a/src/test/control/software/CheckoutTest.java b/src/test/control/software/CheckoutTest.java
new file mode 100644
index 0000000..83d8d77
--- /dev/null
+++ b/src/test/control/software/CheckoutTest.java
@@ -0,0 +1,17 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.control.software.Checkout;
+import org.junit.Test;
+
+public class CheckoutTest {
+	
+	Checkout c = new Checkout();
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}
diff --git a/src/test/control/software/PaymentTest.java b/src/test/control/software/PaymentTest.java
new file mode 100644
index 0000000..eb6927b
--- /dev/null
+++ b/src/test/control/software/PaymentTest.java
@@ -0,0 +1,14 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class PaymentTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}
diff --git a/src/test/control/software/ScanTest.java b/src/test/control/software/ScanTest.java
new file mode 100644
index 0000000..64b6e7a
--- /dev/null
+++ b/src/test/control/software/ScanTest.java
@@ -0,0 +1,14 @@
+package test.control.software;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class ScanTest {
+
+	@Test
+	public void test() {
+		fail("Not yet implemented");
+	}
+
+}

commit 665cc49f1ad212a5b819952ceb5c93aba2fb0a2a
Author: Kadin Sayani <kadinsayani8@gmail.com>
Date:   Thu Mar 10 11:51:02 2022 -0700

    first commit

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..7d3b4d8
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-15">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..ec35539
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software - Test</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..223b166
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=15
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=15
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=15
